## A. Пирамида ли?

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Структуру данных неубывающая пирамида можно реализовать на основе массива. Для этого должно выполняться основное свойство неубывающей пирамиды, которое заключается в том, что для каждого  
``1 ≤ i ≤ n`` выполняются условия:

- Если `2i ≤ n`, то `a[i] ≤ a[2i]`  
- Если `2i + 1 ≤ n`, то `a[i] ≤ a[2i + 1]`

Дан массив целых чисел. Определите, является ли он неубывающей пирамидой.

### Входные данные

Первая строка входного файла содержит целое число  
``n`` (``1 ≤ n ≤ 10⁵``).

Вторая строка содержит ``n`` целых чисел по модулю не превосходящих ``2 * 10⁹``.

### Выходные данные

Выведите ``YES``, если массив является неубывающей пирамидой, и ``NO`` в противном случае.

### Примеры

---

**STDIN**
```c++
5
1 0 1 2 0
```

**STDOUT**
```c++
NO
```

### [Решение](A.cpp)

---

## B. Реализуйте приоритетную очередь

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Ваша очередь должна поддерживать операции, описанные во входных данных. Гарантируется, что размер любой очереди в процессе выполнения команд не превысит  
``10⁶`` элементов.

### Входные данные

Вход содержит описание операций с очередью. Количество операций не более, чем  
``10⁶``. Операции могут быть следующими: Очередь с номером ``k`` — очередь, которая была создана ``k``-й по счёту (индексация очередей начинается с ``0`` и создание кучи происходит в результате операции ``create`` или ``merge``). Гарантируется, что на момент операции над очередью с номером ``k``, она уже создана.

- ``create`` — создать новую очередь
- ``insert k x`` — добавить элемент ``x`` в очередь с номером ``k``
- ``extract-min k`` — удалить из очереди с номером ``k`` минимальный элемент и вывести его в ответ. Если очередь пуста, в ответ требуется вывести звёздочку ``*``
- ``merge k m`` — создать новую очередь путём слияния двух очередей с номерами ``k`` и ``m``
- ``decrease-key k x y`` — заменить в очереди с номером ``k`` значение элемента ``x`` на значение ``y``. Гарантируется, что ``x ≥ y``

В очередь помещаются и извлекаются только целые числа, не превышающие по модулю ``10⁹``.

### Выходные данные

Выведите последовательно результат выполнения всех операций ``extract-min``, по одному в каждой строке ответа.

### Примеры

---

**STDIN**
```c++
create
insert 0 1
insert 0 3
insert 0 5
extract-min 0
create
insert 1 2
insert 1 4
insert 1 6
merge 0 1
decrease-key 2 5 1
extract-min 2
extract-min 2
extract-min 0
extract-min 0
extract-min 0
```

**STDOUT**
```c++
1
1
2
3
5
*
```

### [Решение](B.cpp)

---

## C. Шаверма патруль

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Ни для кого не секрет, что самая вкусная шаверма на Петроградке — “Шаверма от Шера”. Из-за своей внезапной популярности среди студентов у ларька очень много заказов, поэтому владелец в срочном порядке решил нанять  
``n`` шаурмистов, где у ``i``-ого шаурмиста зарплата составляет ``aᵢ`` рублей в минуту.

Жадность Шера сгубила, поэтому он решил грамотно организовать приём всех заказов таким образом, чтобы в момент прихода нового заказа он отдавался свободному работнику с минимальной зарплатой. Если оказалось, что свободных шаурмистов нет, то заказ просто не выполняется.

Шеру важнее минимизировать именно оплату шаурмистам, а не время их работы.

### Входные данные

В первой строке даны два числа ``n`` и ``m`` (``1≤n``, ``m≤3∗10⁵``) — количество шаурмистов и заказов.

Во второй строке даны ``n`` чисел ``a₁, a₂,…, aₙ`` — зарплата каждого из шаурмистов (руб/мин).  
Обратите внимание, что ни у каких двух шаурмистов не совпадает размер зарплаты (все ``aᵢ`` различны).

В следующих ``m`` строках заданы описания заказов, ``i``-я строка описывает ``i``-й заказ:

Два числа ``tᵢ`` и ``fᵢ`` (``1≤tᵢ≤10⁹``, ``1≤fᵢ≤10⁶``) — момент получения ``i``-го заказа и время его выполнения (в минутах).

Во входных данных заказы расположены по возрастанию ``tᵢ``, все ``tᵢ`` различны.

### Выходные данные

Выведите одно число — суммарная зарплата, которую владелец выплатит всем шаурмистам.  
Важно, что зарплату шаурмисты получают только в момент работы.

### Примеры

---

**STDIN**
```c++
4 7
3 2 6 4
1 3
2 5
3 7
4 10
5 5
6 100
9 2
```

**STDOUT**
```c++
105
```

---

### Примечание

Рассмотрим работу заведения поминутно:

- ``t=1``: приходит первый заказ, все шаурмисты свободны. Второй шаурмист занимается приготовлением 3 минуты
- ``t=2``: приходит второй заказ. Второй шаурмист занят, поэтому первый шаурмист занимается приготовлением 5 минут
- ``t=3``: приходит третий заказ, и четвёртый шаурмист занимается приготовлением 7 минут
- ``t=4``: приходит четвёртый заказ. Второй шаурмист освободился и берёт заказ, готовит 10 минут
- ``t=5``: приходит пятый заказ, и последний шаурмист занимается приготовлением 5 минут
- ``t=6``: приходит шестой заказ. Все шаурмисты заняты — заказ отклоняется
- ``t=7``: освобождается первый шаурмист
- ``t=9``: приходит седьмой заказ. Первый шаурмист берёт его и готовит 2 минуты
- ``t=10``: освобождаются третий и четвёртый шаурмисты
- ``t=11``: освобождается первый шаурмист
- ``t=14``: освобождается второй шаурмист

Общая зарплата:  
``3*2 + 5*3 + 7*4 + 10*2 + 5*6 + 2*3 = 6 + 15 + 28 + 20 + 30 + 6`` = ``105``

### [Решение](C.cpp)

---

## D. Я покорю всю Россию

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

У немолодой исполнительницы Альбины в октябре этого года стартует концертный тур “Я покорю всю Россию” во многих городах нашей страны. Каждый город, в котором потенциально будет проходить концерт, обладает тремя параметрами:

- **код города** — уникальное натуральное число
- **рейтинг города** — натуральное число
- **гонорар за выступление** — натуральное число

При выборе следующего города продюссер выбирал город с максимальным рейтингом и гонораром. Если оказывалось так, что город с максимальным рейтингом и город с максимальным гонораром совпадает, то продюссер добавляет его в тур, если же нет, то он связывался с организаторами и пытался повысить гонорар для Альбины. Если просьба была удволетворена, то продюссер вносил этот город в предстоящий тур, если же нет, то он оскорблялся и убирал этот город из потенциального списка городов.

### Входные данные

В первой строчке дано число ``n`` — количество потенциальных городов.

Далее идут ``n`` строчек, где в каждой пробел записаны характеристики города — ``код``, ``рейтинг``, ``гонорар``.

После описания городов на вход дается число ``m`` — количество ответов организаторов на просьбу повышения гонорара.

Далее идут ``m`` строчек двух видов:

- ``YES`` — удволетворительный ответ  
- ``NO`` — неудволетворительный ответ

### Выходные данные

В первой строчке вывести ``m`` элементов, где ``i``-ый элемент указывает ``i``-ый ``код`` города, с которым продюссер связывается для повышения гонорара.

Во второй строчке необходимо вывести последовательность ``кодов`` городов, в которых будет проходить тур.

### Примеры

---

**STDIN**
```c++
5
1 9 10
2 2 2
3 4 3
4 8 1
5 1 4
3
YES
NO
YES
```

**STDOUT**
```c++
4 3 2 
1 4 2 5 
```

---

**STDIN**
```c++
9
0 41 18467
1 6334 26500
2 19169 15724
3 11478 29358
4 26962 24464
5 5705 28145
6 23281 16827
7 9961 491
8 2995 11942
2
NO
YES
```

**STDOUT**
```c++
4 6 
6 3 5
```

### [Решение](D.cpp)

---

## E. Величайший кроссовер

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

В поисках приключений бабушка Дуся решила отдохнуть от огородней суеты и отправиться на отдых в Египет.

Отправившись на экскурсию по пирамидам, бабушка заскучала от скучных рассказов и решила погулять отдельно от туристической группы. Расхаживая по многочисленным лабиринтам, она наткнулась на полностью забитое золотом помещение, посреди которого стояла Лара Крофт и запихивала сокровища в свой рюкзак. В шоке от такой наглости, бабушка мигом подлетела к расхитительнице, чтобы непременно ее отругать и вернуть обратно украденное. Но Дуся не знала, что в пирамиде всюду расставлены ловушки, поэтому случайно наступила на застланную пылью платформу, проход закрылся, а стенки помещения стали медленно сдвигаться навстречу друг другу.

Пока Лара Крофт стояла, вспоминая лучшие моменты своей жизни, бабушка, не теряя ни секунды, оглянулась вокруг и увидела настенные рисунки с подсказками и множество весов, расположенных вдоль стены. Быстро сообразив, что нужно делать, она принялась расставлять сокровища на весы в отсортированном порядке.

### Входные данные

В первой строке входного файла содержится число ``n`` (``1≤ n ≤10⁵``) – количество сокровищ в комнате.

Во второй строке находятся ``n`` целых чисел, по модулю не превосходящих ``10⁹`` — веса сокровищ.

### Выходные данные

Выведите ``n`` чисел — веса сокровищ, раставленных в порядке неубывания, чтобы решить головоломку и спасти попавших в беду туристок.

### Примеры

---

**STDIN**
```c++
10
1 8 2 1 4 7 3 2 3 6
```

**STDOUT**
```c++
1 1 2 2 3 3 4 6 7 8
```

---

### Примечание

- Количество весов совпадает с количеством сокровищ.  
- Необходимо написать сортировку кучей.  
- За решения, основанные на любых других сортировках, баллы ставиться не будут.

### [Решение](E.cpp)

---

## F. Забытая советская закалка

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

В далеком 1965 году в советских яслях ребятишкам решили устроить отдых, поэтому после изучениях дифференциалов, интегралов и рядов, задали найти такое минимальное число, что количество всех его делителей равно ``2ⁿ``. Задача оказалась непосильной даже для советских ребятишек, поэтому воспитатель подсказал, что в факторизации искомого числа степени простых делителей являются степенями двойки без единицы (**степени принимают значения 1, 3, 7, 15 и т.д.**)

### Входные данные

Дано число ``n`` (``1≤ n ≤3∗10⁵``)

### Выходные данные

В первой строчке необходимо вывести ``k`` — количество простых делителей искомого числа.  
Во второй строчке необходимо вывести ``k`` простых делителей через пробел в порядке неубывания.  
Гарантируется, что разложение этого числа содержит не более ``10⁶`` простых чисел, каждое из которые не более ``10⁸``.

### Примеры

---

**STDIN**
```c++
3
```

**STDOUT**
```c++
4
2 2 2 3
```

---

**STDIN**
```c++
1
```

**STDOUT**
```c++
1
2
```

---

**STDIN**
```c++
2
```

**STDOUT**
```c++
2
2 3
```

---

### Примечание

*Ответ должен быть отсортирован!*

**Пояснение к примеру 1**

``2∗2∗2∗3=24``

У числа 24 ровно ``2³`` делителей: ``1, 2, 3, 4, 6, 8, 12, 24``

**Пояснение к примеру 2**

``1∗2=2``

У числа 2 ровно ``2¹`` делителей: ``1, 2``

**Пояснение к примеру 3**

``2∗3=6``

У числа 6 ровно ``2²`` делителей: ``1, 2, 3, 6``

### [Решение](F.cpp)

---

## G. Фибоначчиева куча

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Уважаемые студенты, перед вами новый тип задачи. Вам будет детально описана структура данных, которую не рассматривали на лекциях. Также будут предоставлены ссылки на полезную литературу. От вас же будет требоваться корректная реализация этой структуры данных и готовность ответить на вопросы преподавателя по теории (в том числе вывод ассимптотик).

На этот раз вам предстоит познакомиться с фибкучей. Это некоторая структура данных, поддерживающая операции `add(x)`, `merge(H₁, H₂)`, `extract min()` и `decrease_key(x, delta)`.

Структурно фибкуча — это набор подвешенных деревьев, удовлетворяющих некоторым свойствам:

1. Каждый элемент дерева `≤` своим детям и `≥` родителя.


2. У каждого дерева есть ранг `k`, который определяется так: у корня есть `k` детей, `i`-тый (`i=0,1,2...k−1`) из которых является корнем поддерева ранга `≥i`.

    Заметим, что если мы подвесим дерево за другое дерево того же ранга, мы получим дерево с рангом, увеличенным на `1`. Дерево ранга `0` — просто вершина.


3. Существуют деревья ранга `k*`. Это дерево ранга `k`, у корня которого отсутствует один ребенок. Заметим, что дерево ранга `k*` структурно является деревом ранга `k−1`. Единственным отличием является возможность подвешивать его как `k`-тое поддерево. При переносе дерева в корень кучи ранг `k*` превращается в `k−1`, `k**` — в `k−2`.

**Операции:**

- **`add(x)`** — добавление числа в кучу. Число представляется в виде дерева ранга 0 и добавляется в кучу. Для быстрого добавления оптимально использовать двухсвязный список.  
  Ассимптотическая сложность — `O(1)`.


- **`merge(H₁, H₂)`** — слияние двух куч. Выполняется подвязыванием списка деревьев одной кучи к другому.  
  Ассимптотическая сложность — `O(1)`. Заметим, что в этой и предыдущей операции мы по необходимости обновляем минимум.


- **`extract min()`** — извлечение минимума из кучи. Исходя из свойства 1, минимумом будет являться один из корней кучи. Также заметим, что указатель на минимум мы храним и динамически обновляем при добавлении.  
  При удалении минимума нам необходимо слить список корней кучи с детьми удаленной вершины. Затем пройти по всем корням и слить деревья одинакового ранга. Тогда у нас останется не более одного дерева каждого ранга.  
  Заметим, что в каждом дереве `≥ 2ᵏ` элементов, поэтому ассимптотическая сложность — `O(log n)`.


- **`decrease_key(x, delta)`** — уменьшение ключа какой-либо вершины. При уменьшении числа вершина может оказаться меньше своего родителя. В этом случае переносим эту вершину со всеми поддеревьями в корень кучи, помечая при этом предка звездочкой. Если же предок уже был помечен, то повторяем операцию, пока не дойдем до непомеченного предка.  
  Ассимптотическая сложность — амортизированная `O(1)`.

Для более глубокого понимания предлагаются следующие ресурсы:

- [Лекция Павла Маврина (Преподаватель ИТМО КТ)](https://www.youtube.com/watch?v=CeAjTL-Fshs)
- [Лекция Ильи Степанова (Преподаватель МФТИ ФПМИ)](https://www.youtube.com/watch?v=RE4ZThut8wI)
- [Статья на НИРКЕ](https://neerc.ifmo.ru/wiki/index.php?title=Фибоначчиева_куча)

### Входные данные

Вход содержит описание операций с кучей. Количество операций не более, чем `10⁶`.

Операции могут быть следующими: куча с номером `k` — куча, которая была создана `k`-й по счету (индексация куч начинается с `0` и создание кучи происходит в результате операции `create` или `merge`). Гарантируется, что на момент операции над кучей с номером `k` она уже создана.

- `create` — создать новую кучу


- `insert k x` — добавить элемент `x` в кучу с номером `k`


- `extract-min k` — удалить из кучи c номером `k` минимальный элемент и вывести его в ответ. Если куча пуста, в ответ требуется вывести `*`


- `merge k m` — создать новую кучу путем слияния двух куч с номерами `k` и `m`


- `decrease-key k x y` — заменить в куче с номером `k` значение элемента `x` на значение `y`. Гарантируется, что `x ≥ y`

В куче помещаются и извлекаются только целые числа, не превышающие по модулю `10⁹`.

### Выходные данные

Выведите последовательно результат выполнения всех операций `extract-min`, по одному в каждой строке ответа.

### Примеры

---

**STDIN**
```c++
create
insert 0 1
insert 0 3
insert 0 5
extract-min 0
create
insert 1 2
insert 1 4
insert 1 6
merge 0 1
decrease-key 2 5 1
extract-min 2
extract-min 2
extract-min 0
extract-min 0
extract-min 0
```

**STDOUT**
```c++
1
1
2
3
5
*
```

---

### Примечание

Решение с использованием **НЕ** фибоначчиевой кучи оценивается в **0 баллов**.

---

## H. 🎰

- Лимит времени: **1000 мс**
- Лимит памяти: **256 мб**

### Входные данные

В первой строке дано ``1≤ N ≤6000000``.

В следующих ``N`` строках даны ``N`` чисел (``-10¹⁰⁰⁰ ≤ aᵢ ≤ 10¹⁰⁰⁰``).

### Выходные данные

В единственной строке выведите сумму всех ``N`` чисел.

### Примеры

---

**STDIN**
```c++
3
1
8
4
```

**STDOUT**
```c++
13
```

### [Решение](H.cpp)

---