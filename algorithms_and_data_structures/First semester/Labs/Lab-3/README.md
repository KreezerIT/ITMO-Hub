## A. Фанаты Drives

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Студенты Артём и Игорь любили похрустеть чипсами Drives со вкусом сыра во время перерывов между катками в Doka 2. Однажды они решили создать самую высокую стопку из любимых чипсин, чтобы продемонстрировать, как на примере работают структуры данных в реальной жизни.

### Входные данные

На первой строчке дано число `n` (`1 ≤ n ≤ 10⁶`) — количество операций над чипсинами.

Операции бывают двух видов:

- `+ x` — добавить ещё 1 чипсину с номером `x` сверху стопки (`−10⁹ ≤ x ≤ 10⁹`) (сообщение представляет из себя число — закодированный вкус Drives);
- `-` — убрать 1 чипсину с верхушки.

### Выходные данные

Вывести убранные вкусы чипсин (в порядке удаления), по одному номеру вкуса чипсины в строке.

### Примеры

---

**STDIN**
```c++
6
+ 1
+ 10
-
+ 2
+ 1234
-
```

**STDOUT**
```c++
10
1234
```

---

### Примечание

Свои стек / очередь необходимо реализовывать на **связных списках**, решение на **массивах** будет оценено в **0 баллов**! Использовать встроенные нельзя!
### [Решение](A.cpp)

---

## B. Беспорядки в больнице

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Главврач Анатолий местной больницы №0 крайне озабочен бесконечными беспорядками в очередях к врачу. Какие-то нахалы постоянно лезут без очереди. Поэтому Анатолий ищет человека, способного осуществить контроль за порядком. Эта нелегкая задача выпала именно вам! Реализуйте собственную очередь на связном списке.

### Входные данные

На первой строчке дано число `n` (`1 ≤ n ≤ 10⁶`) — количество операций в списке.

Операции бывают двух видов:

- `+ x` — добавить нового человека в очередь с номером `x` (`−10⁹ ≤ x ≤ 10⁹`);
- `-` — вычеркнуть человека из начала списка.

### Выходные данные

Выведите номера людей в порядке их вычеркивания из списка, по одному номеру на каждой строке.

### Примеры

---

**STDIN**
```c++
4
+ 1
+ 10
-
-
```

**STDOUT**
```c++
1
10
```

---

### Примечание

Свои стек/очередь необходимо реализовывать на **связных списках**, решение на **массивах** будет оценено в **0 баллов**. Использовать встроенные нельзя.

### [Решение](B.cpp)

---

# C. т.о.ч.к.а.

Никита обожает писать сообщения с точкой в конце каждого предложения:

"Доброе утро."

"База."

"Сегодня день сердечек."

"Ты не понимаешь, это другое."

Чтобы стать таким же крутым и талантливым как Никита, вы тоже решили расставить в конце своих сообщений точки.

Но кроме точек, Никита также очень любит **цифровую сортировку** и считает, что все неотсортированные сообщения - не являются важными мыслями, поэтому не читая кидает их в спам.

Отсортировав сообщения по последним `k` символам, вы устали и решили, что Никита и так оценит ваши старания.

Выведите как будет выглядеть последовательность сообщений спустя `k` итераций сортировки, до расстановки точек.

### Входные данные

В первой строке задаются 3 числа:

- `n` — количество Ваших сообщений (`n×k < 10⁷`).
- `k` — длина Ваших сообщений (гарантируется, что у всех одинаковая).
- `t` — сколько букв с конца Вы смогли просмотреть.

### Выходные данные

В `n` строках вывести сообщения в полученном порядке.

### Примеры

---

**STDIN**
```c++
3 3 1
bbb
aba 
baa
```

**STDOUT**
```c++
aba
baa
bbb
```

---

**STDIN**
```c++
3 3 2
bbb
aba 
baa
```

**STDOUT**
```c++
baa
aba
bbb
```

---

**STDIN**
```c++
3 3 3
bbb
aba 
baa
```

**STDOUT**
```c++
aba
baa
bbb
```

### [Решение](C.cpp)

---

# D. Сокровища древних пирамид

Лара Крофт решила отправиться на поиски древних сокровищ в египетские пирамиды. С собой Лара Крофт взяла необычный рюкзак. К сожалению, в него не обязательно возможно сложить абсолютно все найденные сокровища, так как вмещает он ровно `M` драгоценностей.

Так как рюкзак необычный, то добавлять предметы можно только складывая их на другие. Поэтому сначала Лара заполняет рюкзак до тех пор, пока не останется свободного места, складывая сокровища друг на друга.

После заполнения рюкзака и нахождения нового сокровища, она достает сокровище с верха и дна и кладет наверх два самых тяжелых из этих трёх, при чем первее кладет то, что с меньшим весом.

### Входные данные

Первая строка содержит число `N` — количество найденных сокровищ (`1 ≤ N ≤ 10⁵`) и число `M` — сколько сокровищ в себя вмещает рюкзак (`1 ≤ M ≤ 10⁵`).

Следующая строка — `N` чисел (не превышающих `10⁹`), разделенных пробелом, обозначающих веса сокровищ.

### Выходные данные

Выведите, что будет храниться в рюкзаке в конце похода.

### Примеры

---

**STDIN**
```c++
10 5
4 2 28 14 3 40 12 9 1 51
```

**STDOUT**
```c++
12 28 14 40 51
```

### [Решение](D.cpp)

---

## E. Менделеев из параллельной реальности

- Лимит времени: **1000 мс**
- Лимит памяти: **512 мб**

Перебрав главное изобретение великого учёного Д. И. Менделеева, Вы внезапно перенеслись в параллельную реальность и внезапно стали его учеником. Но в один печальный день, когда Менделеев отдыхал под яблоней, от порыва ветра на него свалилось пару яблок, после чего великий учёный забыл, как раскрывать скобки в химических формулах.

В его записях вы вычитали, что в данной реальности существуют всего 26 элементов, обозначаются они заглавными буквами латинского алфавита. Сами же формулы строятся по следующему принципу:

Формула — последовательность латинских букв, разделённых числами, которые обозначают количество элемента, стоящего перед числом; если же числа нет, то количество элемента равно единице.

Пример: `H4ZO2`

Также в формуле могут стоять скобки, которые показывают, что количество элементов внутри скобок должно быть умножено на число после скобок. Так, `H2(O2Z)3` — это то же самое, что `H2O6Z3`.

Напишите программу, которая поможет Менделееву раскрывать скобки в химических формулах.

### Входные данные

На ввод подаётся строка, состоящая из латинских символов, скобок и цифр.  
Длина строки не превышает `10⁷`.  
Строка всегда является правильной формулой.

### Выходные данные

Строка, содержащая правильно раскрытую формулу из ввода.  
Символы должны выписываться в отсортированном относительно алфавита виде.

### Примеры

---

**STDIN**
```c++
H4ZO2
```

**STDOUT**
```c++
H4O2Z
```

---

**STDIN**
```c++
N(OY3)2
```

**STDOUT**
```c++
NO2Y6
```

---

**STDIN**
```c++
Z3(O(N2O3)2)3
```

**STDOUT**
```c++
N12O21Z3
```

---

### Примечание

Свои стек/очередь необходимо реализовывать на **связных списках**, решение на **массивах** будет оценено в **0 баллов**. Использовать встроенные нельзя.

---

## F. Делу время - потехе час!

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Ване нравится предмет АиСД, и, чтобы улучшать свои знания, он не только изучает новый материал, но и регулярно решает задачи. Поэтому Ваня попросил особую программу составить ему ежедневный календарь задач.

Каждая задача имеет на сайте свою сложность, определяемую числом. Чем больше число — тем сложнее задача. В календаре в ячейке дня отмечена сложность задачи этого дня.

Ване скучно просто решать задачи той же или меньшей сложности несколько дней подряд. Если такие промежутки времени попадаются в календаре, то он считает это днями отдыха, так как может быстро решить задачу и заняться другими делами. Также он с нетерпением ждет новой, более сложной задачи относительно текущего дня. Ваня просит Вас составить "трудовой" календарь, то есть для каждого дня отобразить число дней, которые придется прождать до более сложной задачи, чем в текущий день.

### Входные данные

В первой строке дано число `n` (`1 < n < 10⁶`) дней календаря. В следующей строке идут `n` чисел — `i`-е число показывает сложность задачи в `i`-й день (`1 < aᵢ < 10⁶`).

### Выходные данные

Выведите в одну строку `n` чисел. `i`-е число — количество дней, которые придется прождать до более сложной задачи, чем в `i`-й день. Если более сложной задачи не найдется, выведите `-1` для этого дня.

### Примеры

---

**STDIN**
```c++
4
3 4 5 6
```

**STDOUT**
```c++
1 1 1 -1
```

---

**STDIN**
```c++
8
13 14 15 11 9 12 16 14
```

**STDOUT**
```c++
1 1 4 2 1 1 -1 -1
```

---

### Примечание

Решение без использования новых изученных структур данных не засчитывается (**стек**, **очередь**, **список**).

Свои стек/очередь необходимо реализовывать на **связных списках**, решение на **массивах** будет оценено в **0 баллов**. Использовать встроенные нельзя.

### [Решение](F.cpp)

---

## G. Спасение земель Русских

В 1237 году на Русь напали татаро-монголы. Долгое время земля русская терпела издевальства захватчиков. В 1480 году под предводительством великого князя Ивана III собрались бояре со всех княжеств, дабы объединиться и прогнать басурман. Чтобы бояре не разругались и Русь не была порабощена ещё на долгие годы, князь рассадил бояр как можно дальше друг от друга за длинном столом.

### Входные данные

В первой строчке вводится пара целых чисел:  
`N` (`2 ≤ N ≤ 10⁴`) - количество мест за столом и  
`K` (`1 < K < N`) - количество бояр.

Во второй строчке  
`N` координат стульев `aₙ` (`aₙ ≤ 10⁹`), разделённых пробелом.

### Выходные данные

Наибольшее минимальное расстояние между боярами.

### Примеры

---

**STDIN**
```c++
6 3
2 5 6 12 15 22 
```

**STDOUT**
```c++
10
```

---

### Примечание

Все координаты стульев бояр уже отсортированы по возрастанию.

### [Решение](G.cpp)

---

## H. Остаться в живых

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Вася попал на необитаемый остров и уже около двух дней отчаянно ищет способ спастись от мучительной и одинокой смерти.

Он уже почти сдался, когда судьба сделала ему подарок.

К пустынному песчаному берегу его острова прибило обломок его старого корабля, который представлял собой  
``N`` сколоченных досок разной длины.

Васе очень повезло, и **3 из четырех** сторон его будущего плота были идеально ровными. Но, т.к. доски имели разную длину, четвёртая сторона представляла собой случайным образом торчащие доски.

Чтобы плот был устойчив, он должен иметь форму прямоугольника и как можно большую площадь. Чтобы получить хороший плот, Вася может обломать некоторые доски, а некоторые и вовсе оторвать.

Помогите Васе определить максимальную площадь плота, которую он может получить. Каждая доска имеет ширину 1 метр.

``N ≤ 10⁶``  
``aᵢ ≤ 10⁹``

### Входные данные

1-я строка содержит положительное целое число ``N``, обозначающее количество досок.  

2-я строка содержит ``N`` положительных целых чисел — длины досок в метрах в том порядке, в котором они сколочены.

### Выходные данные

Целое число — максимально возможная площадь плота в квадратных метрах.

### Примеры

---

**STDIN**
```c++
5
1 2 3 4 5
```

**STDOUT**
```c++
9
```

---

### Примечание

Свои стек/очередь необходимо реализовывать на **связных списках**, решение на **массивах** будет оценено в **0 баллов**. Использовать встроенные нельзя.

### [Решение](H.cpp)

---

## I. Давай поженимся

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

В 2077 году на телеканале "Найт-Сити 1" выходит продолжение культовой передачи "Давай поженимся" с новой концепцией серий. За это время в обществе приобрела популярность нумерология, поэтому было принято решение подбирать на шоу пары по совместимости натальных карт.

Так для каждого участника был посчитан индивидуальный коэффициент натальной карты, а чтобы посчитать совместимость потенциальных невесты и жениха, необходимо сложить их коффициенты. Продюсеры шоу сняли выпуски с каждой возможной парой участников и расположили их в сезоне в порядке увеличения совместимости пар.

Чтобы не смотреть неинтересные выпуски вы решили начать с  
``k``-ой серии.

### Входные данные

В первой строке дано два числа  
``n`` и ``k`` (``1 ≤ n ≤ 10⁵``, ``1 ≤ k ≤ n²``).

Во второй строке дано ``n`` чисел — коэффициенты натальных карт женщин (``1 ≤ coef ≤ 10⁹``).

Во третьей строке дано ``n`` чисел — коэффициенты натальных карт мужчин (``1 ≤ coef ≤ 10⁹``).

### Выходные данные

Одно число — ``k``-ая сумма коэффициентов.

### Примеры

---

**STDIN**
```c++
5 10
3 2 1 5 2
4 8 3 1 2
```

**STDOUT**
```c++
5
```

### [Решение](I.cpp)

---

## J. Андрюша

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

В далёком 2010 году мальчик по имени Андрюша фанател по карточкам серии "Человек-Паук". У него была самая большая коллекция в садике.

На каждой карточке написано имя персонажа и его количество урона. Чтобы быстрее искать карточки в огромной коллекции, Андрюша придумал раскладывать их по возрастанию урона.

Мама мальчика увидела в ребёнке гения, поэтому твёрдо решила отдать его в MIT, с раннего возраста обучая основам алгоритмического мышления. Зная про увлечение карточками с Человеком-Пауком, мама решила задать ему задачки следующего вида:

- `Count L R` — узнать количество карточек, урон которых лежит в отрезке `[L:R]`
- `Sum L R` — узнать сумму урона всех карточек, урон которых лежит в отрезке `[L:R]`
- `Xor L R` — узнать xor уронов всех карточек, урон которых лежит в отрезке `[L:R]`

### Входные данные

В первой строке дано число `n (1 ≤ n ≤ 10⁵)` — количество карточек в коллекции Андрюши.

Во второй строке — `n` чисел, разделённых пробелом — уроны карточек.  
Урон — целое положительное число, не более чем `10⁵`.

В третьей строке — `n` названий карточек, разделённых пробелом (название карточки — одно необязательно уникальное слово, длиной не более 10).

Таким образом, урон `i`-й карточки — `i`-е число во второй строке, а название — `i`-е слово в третьей строке.

В следующей строке дано число `q (1 ≤ q ≤ 10⁵)` — количество запросов.

В следующих `q` строках — описания запросов в формате, данном выше.

### Выходные данные

Выведите массив карточек, отсортированный по возрастанию урона, в следующем формате:

- Первая строка — `n` чисел, разделённых пробелом — уроны карточек.
- Вторая строка — `n` названий карточек, разделённых пробелом.

Далее выведите ответы на задачки от мамы Андрюши — по одному числу в одной строке на каждый запрос.

### Примеры

---

**STDIN**
```c++
5
1 5 6 1 2
fireman policeman spiderman thor ironman
3
Count 1 4 
Sum 1 5
Xor 1 3
```

**STDOUT**
```c++
1 1 2 5 6
fireman thor ironman policeman spiderman
3
9
2
```

---

### Примечание

Требуется реализовать **устойчивую сортировку подсчётом**.

Обратите внимание, что при выводе в конце первых двух строк пробелы не стоят.

---

## K. Скрепышовая многоножка

- Лимит времени: **1000 мс**
- Лимит памяти: **50 мб**

Режиссер Джерри Севен и компания “Магнит” решили устроить коллаборацию.

Рекламная компания заключается в том, что участникам онлайн-конкурса необходимо найти цикл в связанных друг за другом скрепышах.

### Входные данные

В первой строке дано число  
``n`` (``1 ≤ n ≤ 10⁶``) — количество скрепышей.

Во второй строчке даны числа ``aᵢ`` — номер скрепыша, закрепленного следующим за ``i``-м скрепышом.  
Индексация начинается с ``1``.

### Выходные данные

Вывести длину цикла, если цикла нет, то необходимо вывести ``−1``.

### Примеры

---

**STDIN**
```c++
6
3 4 5 5 6 2
```

**STDOUT**
```c++
4
```

---

**STDIN**
```c++
3
2 3
```

**STDOUT**
```c++
-1
```

---

### Примечание

Без построения списка задача НЕ считается решенной.

Пользоваться map, set, массивом подсчета нельзя.

Без построения списка задача НЕ считается решенной.

Второй пример из условия корректный.

Петля не является циклом.

### [Решение](K.cpp)

---

