## A. Двоичный код Грея [доп. балл]

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Двоичный код Грея — способ перечисления всех `2ⁿ` битовых строк из `n` бит таким образом, что при следующем перечислении изменяется только один бит, само изменение детерминировано (каждый бит в последовательности определённым образом изменяется при переходе от одного числа к следующему) и регулярно (каждое число в последовательности имеет одинаковое количество единичных битов).

Например, двоичный код Грея для `n = 4` выглядит так:
`0000, 0001, 0011, 0010, 0110, 0111, 0101, 0100, 1100, 1101, 1111, 1110, 1010, 1011, 1001, 1000`

### Входные данные

На вход подаётся одно число `n` (`n ≤ 20`) — порядок кода Грея.

### Выходные данные

Необходимо вывести `2ⁿ` строк, описывающих код Грея для `n` бит.

### Примеры

---

**STDIN**
```c++
3
```

**STDOUT**
```c++
000
001
011
010
110
111
101
100
```

### [Решение](A.cpp)

---

## B. Пусть утро будет нежным!

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Сидя у себя в офисе в Калифорнии, Марк Цукерберг чуть не подавился молочным латте без лактозы, когда увидел, какое количество памяти занимают картинки с добрым утром вашей бабушки в WhatsApp. В скором порядке он созвал внезапную планёрку талантливейших кодировщиков со всего мира, где единогласно пришли к решению о сжатии всех картинок через алгоритм **LZ78**.

### Входные данные

Строка `s` (`|s| ≤ 5 * 10⁵`), состоящая из строчных латинских букв, обозначающая метаданные файла, который необходимо сжать.

### Выходные данные

На каждой новой строчке необходимо последовательно вывести список пар `pos` и `next`, где `pos` — номер в словаре самого длинного найденного префикса и `next` — символ, который следует за этим префиксом.

### Примеры

---

**STDIN**
```c++
abcaba
```

**STDOUT**
```c++
0 a
0 b
0 c
1 b
1 
```

---

**STDIN**
```c++
abacababacabc
```

**STDOUT**
```c++
0 a
0 b
1 c
1 b
4 a
0 c
4 c
```

### [Решение](B.cpp)

---

## C. Облачный кризис

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Все презентации для лекций по АиСД хранятся на диске. Однако из-за обилия информации размеры презентаций всё росли и росли, пока в какой-то момент на диске не закончилась память. Талантливые студенты предложили свою помощь и решили закодировать все презентации с помощью **кода Хаффмана**.

### Входные данные

Дана строка `s` из латинских букв нижнего регистра, которая представляет собой некоторый код презентации.  
`|s| ≤ 10⁶`

### Выходные данные

Выведите **длину** строки `s`, закодированной кодом Хаффмана.

### Примеры

---

**STDIN**
```c++
daccaba
```

**STDOUT**
```c++
13
```

### [Решение](C.cpp)

---

## D. Помогите Элли [доп. балл]

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Ураган перенёс домик Элли в Волшебную страну, и чтобы вернуться домой, девочке нужна помощь великого волшебника Гудвина. Элли направляется в Изумрудный город, где тот самый Великий и Ужасный Гудвин живёт. Однако волшебника дома не оказалось. Тогда Элли рассказали про таинственный мессенджер EmeraldGram, при помощи которого можно связаться с Гудвином. К сожалению, в Волшебной стране нет хороших программистов, и задача реализовать дешифратор для EmeraldGram была не из простых, но девочка узнала, что сообщения там закодированы при помощи **алгоритма Хэмминга**. К счастью, у Элли оказался Ваш номер телефона, и она попросила Вас реализовать дешифратор для EmeraldGram. После передачи по сети необходимо определить, появилась ли какая-то ошибка из-за помех и, при возможности, восстановить сообщение. Помогите Элли связаться с Гудвином.

### Входные данные

Первая строка входных данных содержит целое число `1≤t≤10³` — количество строк. Далее следуют `t` строк, закодированных **алгоритмом Хэмминга**.

### Выходные данные

Выведите `t` раскодированных строк.

### Примеры

---

**STDIN**
```c++
3
0000101011011
01101010000100100
01100100111001111001011001

```

**STDOUT**
```c++
010111011
110100010010
101011100111001011001
```

---

### Примечание

1. Битовый блок кодирования — **вся строка**
2. Алгоритм Хэмминга:
    - Контрольные биты располагаются в **степенях двойки** и изначально принимаются равными `0`.
    - Информационные биты (биты исходной последовательности) располагаются в прямом порядке.
    - Поиск позиции с ошибкой происходит путём **суммы позиций всех неверных контрольных битов** (на основании их пересчёта).
    - Алгоритм **исправляет только одну ошибку** на всю последовательность.
    - Обнаружение дополнительных ошибок не предусмотрено.
    - Разбиение на блоки не предусмотрено.

---

## E. Тик-ток! Пост-Панк!

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Популярная девочка Саша с ИСа обожает записывать тик-токи для своих многочисленных подражателей. И вот одним воскресным вечером, отдыхая с друзьями, её рука потянулась к новенькому айфону, чтобы в очередной раз порадовать поклонников новым контентом. К большому сожалению, память её телефона оказалась совсем переполнена старыми видео, которые Саше совсем не хотелось удалять.

Добрые однокурсники подсказали блогерше сжать свои видео с помощью **арифметического кодирования**.

### Входные данные

Строка `s` (`∣s∣ ≤ 10⁵`), состоящая из строчных латинских букв, обозначающая метаданные файла, который необходимо закодировать.

### Выходные данные

Результат кодирования строки `s` с точностью до `6`-ого знака.

### Примеры

---

**STDIN**
```c++
abacaba
```

**STDOUT**
```c++
0.410849
```

---

### Примечание

При выборе ответа, всегда необходимо брать **левую границу** возможных значений.

---

## F. Бедный Ваня

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Ваня всегда мечтал стать художником, но его работы были настолько посредственными, что никто не хотел их покупать. Тогда он решил, что станет арт-диллером, но найти достойных живописцев он не сумел, поэтому придумал мошенническую схему с продажей копий работ известных художников, которые он выдавал за подлинники.

В галерее, в которой работает Ваня, каждой картине соответствует **уникальный код**. Чтобы заработать больше денег, Ваня решил продавать работы Павлу Четверякову — самому известному потомственному коллекционеру города.

Друзья арт-диллеры рассказали Ване, что у Павла есть особый алгоритм, который определяет, является ли картина подлинником, и рассказали, как его можно обойти. Четверяков сравнивает уникальный код из собственной базы данных с кодом картины, которую собирается приобрести. Эти коды достались ему от дедушки, который записывал их вручную, поэтому некоторые из них не совсем корректны, поэтому Павел использует коэффициент  
`k` — отвечающий за допустимое количество отличий от кода картины, которую он планирует купить. Если отличий меньше, чем `k`, то он приобретает её к себе в коллекцию.

Ване удалось раздобыть коды Павла. Помогите ему узнать, приобретёт ли коллекционер его работу.

### Входные данны`е

В первой строке задаются три числа:
- `n < 5 * 10⁶` — длина закодированного с помощью **RLE** кода Павла Четверякова,
- `m < 5 * 10⁶` — длина закодированного с помощью **RLE** кода картины Вани,
- `k < 5 * 10⁹` — количество возможных отличий.

### Выходные данные

Вывести `Yes`, если Павел приобретёт картину, иначе вывести `No`.

### Примеры

---

**STDIN**
```c++
3 9 72
X91
m86H1e3l1
```

**STDOUT**
```c++
No
```

---

**STDIN**
```c++
8 23 1275
q788x408
e385p336J434Y26C2Z6X5Z2
```

**STDOUT**
```c++
Yes
```

---

### Примечание

Незакодированная строка не содержит цифр.

---

## G. Император Микки и его система защиты

- Лимит времени: **1000 мс**
- Лимит памяти: **512 мб**

В империи ТИМО существует особая система передачи данных. Для защиты от чужих глаз используется `RLE`-сжатие, но есть нюанс — для еще большей защиты данные передаются в закодированном виде. Сам процесс дешифрования занимает долгое время, потому император Микки попросил вас ему помочь.

Алгоритм дешифрования таков:

Задается бинарное дерево на `n` вершин. Вершина `1` является корнем. Каждая вершина имеет не более двух детей: левый ребенок имеет номер `2·v`, правый — `2·v + 1` (при условии, что их номера не превосходят `n`). В каждой из вершин находится значение.

После происходят `q` изменений. Дается список из `q` целых чисел:  
`k₀, k₁, k₂, ..., k₍q₋₁₎`, где `kᵢ` — номер вершины, относительно которой происходит изменение.

Введем обозначения:

- `p` — предок вершины `v`
- `pp` — предок вершины `p` (если существует)
- `vₗ`, `vᵣ` — левый и правый дети `v`
- `pₗ`, `pᵣ` — левый и правый дети `p`

В таком случае обмен задается следующим образом:

- Если `p` — левый ребенок вершины `pp`, то `v` становится левым ребенком `pp`, иначе — правым.


- Если `v` — левый ребенок вершины `p`, то:
    - `p` становится левым ребенком `v`
    - `vᵣ` остается правым ребенком `v`
    - `vₗ` становится левым ребенком `p`
    - `pᵣ` остается правым ребенком `p`


- Если `v` — правый ребенок вершины `p`, то:
    - `p` становится правым ребенком `v`
    - `vₗ` остается левым ребенком `v`
    - `vᵣ` становится правым ребенком `p`
    - `pₗ` остается левым ребенком `p`

Если вершина, относительно которой должно произойти изменение, является корнем дерева — изменение не происходит.

Далее выполняется `LRV(v)`-обход (левый-правый-вершина) получившегося дерева, и номера вершин записываются на листочек.

Такой алгоритм дешифрования необходимо применить как для чисел-коэффициентов повторения символов, так и для самих символов. После дешифрования данных их следует разжать, используя принцип `RLE`-сжатия.  
`i`-ое число в обходе дерева коэффициентов соответствует `i`-ой букве в обходе дерева символов.

Замечание: *гарантируется, что количество символов и количество коэффициентов одинаковы. Алфавит символов — английский алфавит*.

(`1 ≤ n ≤ 10⁶`, `1 ≤ q ≤ 5·10³`)

### Входные данные

- **1**я строка содержит два целых числа `n` и `q₁` — количество вершин и количество изменений в дереве коэффициентов.


- **2**я строка содержит `n` целых чисел — значения коэффициентов.


- **3**я строка содержит `q₁` целых чисел (`k₁ᵢ` — число - изменение относительно вершины `i`).


- **4**я строка содержит два целых числа `n` и `q₂` — количество вершин и количество изменений в дереве символов.


- **5**я строка содержит `n` символов, разделенных пробелами.


- **6**я строка содержит `q₂` целых чисел `k₂ᵢ` — число - изменение относительно вершины `i`).

### Выходные данные

Выведите дешифрованную и разжатую строку символов.

### Примеры

---

**STDIN**
```c++
4 3
11 11 11 9
3 4 3
4 4
I T M O
4 1 3 2
```

**STDOUT**
```c++
OOOOOOOOOOOTTTTTTTTTIIIIIIIIIIIMMMMMMMMMMM
```

---
