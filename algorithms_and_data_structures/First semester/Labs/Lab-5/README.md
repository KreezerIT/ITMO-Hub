## A. Ёлки-палки 2.0

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Несмотря на все ваши старания, новогодняя бинарная ёлка в ИТМО все равно упала. Недолго думая, руководство решило обратиться за помощью к уважаемым коллегам из нового физтеха. Проведя расчеты и эксперименты, физики предложили вам такое решение — сделать из обычного бинарного дерева бинарное дерево поиска и нарядить дерево так, чтобы никакие две ветки не отличались высотой более чем на 1.

### Входные данные

В первой строчке дано ``n`` (``1≤ n ≤10⁶``) — количество вершин.

Во второй строчке дано ``n`` чисел (``-10⁹≤ aᵢ ≤10⁹``), разделенных пробелом, — количество украшений в вершине дерева, отсортированных по возрастанию. Также не существует двух таких вершин, количества украшений которых одинаковы.

### Выходные данные

Вывести бинарное дерево через preorder обход. В случае нескольких возможных ответов нужно вывести тот, в котором корень каждого поддерева минимально возможный.

### Примеры

---

**STDIN**
```c++
5 
-10 -3 0 5 9
```

**STDOUT**
```c++
0 -10 -3 5 9
```

### [Решение](A.cpp)

---

## B. Предки — наше всё

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Компания OOO "Предки — наше все" занимается построением генеалогического древа. Так оказалось, что вместо стажировки в Яндексе вы решили пойти работать в эту компанию для того, чтобы оплатить свое образование. К несчастью, данные о предках ваших клиентов постоянно меняются, поэтому часто приходится его редактировать. Удивительным образом вы заметили, что генеалогического древа для текущего клиента является бинарным деревом, где в вершине значение является возрастом данного человека. Дабы автоматизировать процесс и ускорить процесс подготовки проекта, вы решили запрогать все редактирование и трассировку с помощью следующих комманд:

- ``insert x`` — добавить нового человека с возрастом ``x`` в древо. Если в дереве уже есть человек с возрастом ``x``, то добавлять нового не надо.


- ``delete x`` — удалить из дерева человека с возрастом ``x``. Если человека с возрастом ``x`` в древе нет, ничего делать не надо.


- ``exists x`` — если есть человек с возрастом ``x`` есть в древе, вывести ``"true"``, если нет — ``"false"``.


- ``next x`` — вывести минимальный возраст в древе, строго больший ``x``, или ``"none"``, если такого нет.


- ``prev x`` — вывести максимальный возраст в древе, строго меньший ``x``, или ``"none"``, если такого нет.

В древо помещаются и извлекаются только целые числа, не превышающие по модулю ``10⁹``.

### Входные данные

Операций с древом, их количество не превышает ``100``.

### Выходные данные

Выведите последовательно результат выполнения всех операций ``exists``, ``next``, ``prev``. Каждый ответ на новой строчке.

### Примеры

---

**STDIN**
```c++
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```

**STDOUT**
```c++
true
false
5
3
none
3
```

### [Решение](B.cpp)

---

## C. И здесь К-ый максимум...

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Бабушка Дуся вернулась с невероятного приключения к себе домой в деревню. За время её отдыха, яблоня в огороде выросла и стала плодоносить. Из-за своей привязанности и любви к дереву, она внимательно следила за каждым появившимся яблоком и научилась на глаз определять его вес. Своим талантом она известна на всю деревню, поэтому соседи, желая проверить её, просили назвать ``k``-й максимум среди весов всех яблок, находящихся на дереве.

### Входные данные

На первой строчке находится число ``n`` (``1≤n≤10⁵``) — количество команд.

Далее на ``n`` строчках идут команды трёх типов:

- ``1 k`` — появляется новое яблоко c весом ``k``
- ``0 k`` — бабушку просят назвать ``k``-й максимум
- ``-1 k`` — яблоко с весом ``k`` падает с дерева

``|k|≤10⁹``

### Выходные данные

На каждую просьбу соседов вывести ``k``-ый максимум.

### Примеры

---

**STDIN**
```c++
11
1 5
1 3
1 7
0 1
0 2
0 3
-1 5
1 10
0 1
0 2
0 3
```

**STDOUT**
```c++
7
5
3
10
7
3
```

---

### Примечание

Вес яблока с момента появления не меняется.  

Яблоки, упавшие с дерева, остаются лежать на земле.

### [Решение](C.cpp)

---

## D. Ёлки-палки

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

На Новый год в ИТМО возле входа в вуз ставится большая красиво украшенная ёлка. Прошлый год не был исключением, но поскольку ИТМО — первый неклассический вуз, то вместо обычной ёлки решили установить ёлку в виде бинарного дерева, где в каждой вершине свое количество украшений согласно свойствам бинарного дерева. К сожалению, со временем дерево накренилось вправо, из-за чего было принято решение снять самые правые украшения на каждом уровне.

### Входные данные

Первая строчка ``n`` (``1≤n≤10³``) — количество вершин в дереве

Вторая строчка — ``n`` чисел (``−10⁹≤aᵢ≤10⁹``), задающие количество украшений в каждой вершине дерева построенного через последовательный ``insert``.

### Выходные данные

Вывести через пробел количество украшений самых правых вершин на каждом уровне, начиная с ``1``.

### Примеры

---

**STDIN**
```c++
11
100 50 20 19 18 17 25 24 57 160 110
```

**STDOUT**
```c++
100 160 110 25 24 17
```

### [Решение](D.cpp)

---

## E. Три друга

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Три друга списывают лабораторную работу, каждый из них списывает по ``n`` различных задач. Поскольку друзья не очень умные, они не меняют названия отправляемых на проверку файлов.

По истечении времени, отведенного на написание лабораторной, преподаватель запускает бан-машину и ставит баллы по следующим правилам:

- если задача написана только у одного студента, то этот студент получает **3 балла**, поскольку эту задачу он не списывал и не давал списывать;
- если задача списана ровно у двух студентов, то каждый из них получает **по 1 утешительному баллу**;
- если задача списана всеми тремя студентами, то за нее **баллы не начисляются никому**.

Выведите финальное количество баллов у каждого студента.

В рамках этой задачи будем считать, что Бан-машина считает решения списанными, если у них полностью совпадают имена файлов.

### Входные данные

В первой строке входных данных дается число ``n`` (``1 ≤ n ≤ 10000``) — количество задач в лабораторной.

Следующие три строки содержат по ``n`` различных слов в каждой — названия файлов с решениями, отправленных каждым из студентов.

### Выходные данные

Необходимо вывести **3 числа** — количество баллов у первого, второго и третьего студента соответственно.

### Примеры

---

**STDIN**
```c++
3
fir sec thi
thi fir sec
aaa sec bbb
```

**STDOUT**
```c++
2 2 6
```

---

### Примечание 

Решения, написанные при помощи **сортировок**, **бинпоиска** или **встроенных деревьев** не засчитываются. **Set**, **Map** и т.п. — запрещены.  

***В реальности бан-машина работает намного сложнее ;)***

### [Решение](E.cpp)

---

## F. Подельник

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Тяжело себе представить более несчастного человека, чем тот, кто планировал заботать предмет за ночь перед экзаменом и не преуспел в этом. Именно такая беда приключилась с незадачливым студентом Славой, поэтому он отлетел на допсу по алгоритмам. Во второй раз Слава решил не рисковать и попросил вас помочь ему закрыть этот ужасный предмет (готовиться заранее — удел слабых).

Наступил день экзамена. Славе повезло, так как у экзаменатора в этот день было хорошее настроение. Преподаватель нарисовал перед ним бинарное дерево поиска и попросил написать порядок вывода вершин при каждом виде обхода этого дерева. Слава записал три строчки чисел и отправил их вам на проверку. Ваша задача — написать программу, проверяющую корректность результатов Славы. Другими словами, может ли существовать дерево с таким порядком вершин при обходах. Помогите Славе, его жизнь в ваших руках!

### Входные данные

В первой строке записано число ``n`` (``n ≤ 10⁷``) — количество вершин в дереве. В следующих 3 строках записаны по ``n`` чисел — результаты ``pre-`` , ``in-``  и ``post-`` *order* обхода дерева соответственно.

### Выходные данные

В единственной строке выведите ``YES`` при валидности обходов и ``NO`` в обратном случае.

### Примеры

---

**STDIN**
```c++
6
3 2 1 5 4 6
1 2 3 4 5 6
1 2 4 6 5 3
```

**STDOUT**
```c++
YES
```

---

**STDIN**
```c++
6
3 2 1 5 4 6
1 2 3 4 5 6
1 6 2 5 3 4
```

**STDOUT**
```c++
NO
```

---

**STDIN**
```c++
6
3 2 1 9 4 6
1 2 3 4 5 6
1 2 4 6 5 3
```

**STDOUT**
```c++
NO
```

---

### Примечание

При равенстве значений вершин дерева одинаковые значения находятся в правом поддереве

### [Решение](F.cpp)

---

## G. Всё, давай, я очень занятой.

- Лимит времени: **1000 мс**
- Лимит памяти: **256 мб**

Денис — очень занятой человек. Поэтому он нанял Вас, чтобы оптимизировать свои жизненные процессы.

Самое важное для Дениса — это саморазвитие, из-за чего для каждого дня он составляет расписание в виде бинарного дерева. Каждая вершина которого — это польза от завершения некоторой работы в течение дня.

Чтобы получать максимальную пользу от каждой минуты своего драгоценного времени, Денис ищёт в своем расписании оптимальный участок для работы. Таковым он называет поддерево, которое является BST с максимальной пользой (сумма вершин в BST).

### Входные данные

Ввод начинается с значения в корне дерева.

- ``l`` — спуск в левого ребёнка
- ``r`` — спуск в правого ребёнка
- ``u`` — подъём наверх

В единственной строке подаётся ``n`` (``n ≤ 11 ∗ 10⁶``) значений.

### Выходные данные

Вывести в единственной строке число — максимальную пользу.

### Примеры

---

**STDIN**
```c++
1 l 4 l 2 u r 4 u u r 3 l 2 u r 5 l 4 u r 6 u u u u
```

**STDOUT**
```c++
20
```

---

**STDIN**
```c++
4 l 3 l 1 u r 2 u u u
```

**STDOUT**
```c++
2
```

---

**STDIN**
```c++
-4 l -2 u r -5 u u
```

**STDOUT**
```c++
0
```

---

**STDIN**
```c++
2 u
```

**STDOUT**
```c++
2
```

### [Решение](G.cpp)

---

## H. Доска задач

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

В крупной компании два разработчика — Николай и Степан работают над различными задачами. Каждый разработчик может взять и отказаться от задачи. Также Степан, ввиду своей нерасторопности, может делегировать все свои задачи Николаю. Для удобства взаимодействия с доской задач разработчикам были присвоены идентификаторы. Николай имеет идентификатор, равный 0, а Степан — равный 1.

Так, с доской могут производиться следующие операции:

- ``0 ID task`` — разработчик с идентификатором ``ID`` берет задачу с номером ``task``.
- ``1 ID task`` — разработчик с идентификатором ``ID`` отказывается от задачи с номером ``task``.
- ``2`` — все задачи переходят Николаю.

После каждой передачи задач нужно отчитываться перед менеджером, поэтому после этой операции требуется вывести номера задач в отсортированном виде без пробела на конце.

### Входные данные

В первой строке подается ``n`` (``1 ≤ n ≤ 25000``) — количество операций.

В следующих ``n`` строках подаются команды одного из трех видов. Гарантируется, что номер задачи неотрицателен и не превышает ``10⁹``.

### Выходные данные

При каждой операции ``2`` вывести номера задач Николая **в отсортированном виде**.

### Примеры

---

**STDIN**
```c++
1
0 1 1 
```

**STDOUT**
```c++

```

---

**STDIN**
```c++
2
0 1 2
2
```

**STDOUT**
```c++
2
```

---

### Примечание

Если после передачи задач получается так, что у Николая их нет, то выводить ничего не нужно. Также при удалении элемента, которого не существует, ничего не происходит.

Требуется хранить только уникальные значения.

Передача задач должна производиться за **O(n + m)**. Иная асимптотика будет оценена в **0 баллов**.

### [Решение](H.cpp)

---
