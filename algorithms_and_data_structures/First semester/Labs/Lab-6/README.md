## A. Проверка сбалансированности

- Лимит времени: **1000 мс**  
- Лимит памяти: **128 мб**

АВЛ-дерево является сбалансированным в следующем смысле: для любой вершины высота ее левого поддерева отличается от высоты ее правого поддерева не больше, чем на единицу.

Введем понятие баланса вершины: для вершины дерева `V` ее баланс `B(V)` равен разности высоты правого поддерева и высоты левого поддерева.

Таким образом, свойство АВЛ-дерева, приведенное выше, можно сормулировать следующим образом: для любой ее вершины `V` выполняется следующее неравенство: `−1 ≤ B(V) ≤ 1`.

Дано двоичное дерево поиска. Для каждой его вершины требуется определить ее баланс.

### Входные данные

Входные данные содержат описание двоичного дерева.

В первой строке файла находится число `n` (`1 ≤ n ≤ 2⋅10⁵`) - число вершин в дереве. В последующих `n` строках файла находятся описания вершин дерева. В `(i+1)`-ой строке файла (`1 ≤ i ≤ n`) находится описание `i`-ой вершины, состоящее из трех чисел `Kᵢ`, `Lᵢ`, `Rᵢ`, разделенных пробелами — ключа в `i`-ой вершине (`|Kᵢ| ≤ 10⁹`), номера левого ребенка `i`-ой вершины (`i < Lᵢ ≤ n` или `Lᵢ = 0`, если левого ребенка нет) и номера правого ребенка `i`-ой вершины (`i < Rᵢ ≤ n` или `Rᵢ = 0`, если правого ребенка нет).

Все ключи различны. Гарантируется, что данное дерево является деревом поиска.

### Выходные данные

Для `i`-ой вершины в `i`-ой строке выведите одно число — баланс данной вершины.


### Примеры

---

**STDIN**
```c++
6
-2 0 2
8 4 3
9 0 0
3 5 6
0 0 0
6 0 0
```

**STDOUT**
```c++
3
-1
0
0
0
0
```

---

## B. Делаю я левый поворот

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Для балансировки АВЛ-дерева при операциях вставки и удаления производятся левые и правые повороты. Левый поворот в вершине производится, когда баланс этой вершины больше `1`, аналогично, правый поворот производится при балансе, меньшем `-1`.

Существует два разных левых (как, разумеется, и правых) поворота: **большой** и **малый** левый поворот.

Заметим, что если до выполнения малого левого поворота был нарушен баланс только корня дерева, то после его выполнения все вершины становятся сбалансированными, за исключением случая, когда у правого ребенка корня баланс до поворота равен `1`. В этом случае вместо малого левого поворота выполняется **большой левый поворот**.

Дано дерево, в котором **баланс дерева равен** `2`. Сделайте левый поворот.

### Входные данные

Входные данные содержат описание двоичного дерева.

В первой строке файла находится число `n` (`1 ≤ n ≤ 2⋅10⁵`) — число вершин в дереве.  
В последующих `n` строках файла находятся описания вершин дерева.  
В (`i+1`)-ой строке файла (`1 ≤ i ≤ n`) находится описание `i`-ой вершины, состоящее из трех чисел `Kᵢ`, `Lᵢ`, `Rᵢ`, разделенных пробелами — ключа в `i`-ой вершине (`|Kᵢ| ≤ 10⁹`), номера левого ребенка `i`-ой вершины (`i < Lᵢ ≤ n` или `Lᵢ = 0`, если левого ребенка нет) и номера правого ребенка `i`-ой вершины (`i < Rᵢ ≤ n` или `Rᵢ = 0`, если правого ребенка нет).

Все ключи различны. Гарантируется, что данное дерево является деревом поиска. Все ключи различны. Баланс корня дерева (вершины с номером `1`) равен `2`, баланс всех остальных вершин находится в пределах от `−1` до `1`.

### Выходные данные

Выведите в том же формате дерево после осуществления левого поворота.  
Нумерация вершин может быть произвольной при условии соблюдения формата.  
Так, номер вершины должен быть меньше номера ее детей.

### Примеры

---

**STDIN**
```c++
7
-2 7 2
8 4 3
9 0 0
3 5 6
0 0 0
6 0 0
-7 0 0
```

**STDOUT**
```c++
7
3 2 3
-2 4 5
8 6 7
-7 0 0
0 0 0
6 0 0
9 0 0
```

---

## C. Вставка в АВЛ-дерево

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Вставка в АВЛ-дерево вершины `V` с ключом `X` при условии, что такой вершины в этом дереве нет, осуществляется следующим образом:

- находится вершина `W`, ребенком которой должна стать вершина `V`;

- вершина `V` делается ребенком вершины `W`;

- производится подъем от вершины `W` к корню, при этом, если какая-то из вершин несбалансирована, производится, в зависимости от значения баланса, левый или правый поворот.

Первый этап нуждается в пояснении. Спуск до будущего родителя вершины `V` осуществляется, начиная от корня, следующим образом:

Пусть ключ текущей вершины равен `Y`.

- Если `X < Y` и у текущей вершины есть левый ребенок, переходим к левому ребенку.


- Если `X < Y` и у текущей вершины нет левого ребенка, то останавливаемся, текущая вершина будет родителем новой вершины.


- Если `X > Y` и у текущей вершины есть правый ребенок, переходим к правому ребенку.


- Если `X > Y` и у текущей вершины нет правого ребенка, то останавливаемся, текущая вершина будет родителем новой вершины.

Отдельно рассматривается следующий крайний случай: если до вставки дерево было пустым, то вставка новой вершины осуществляется проще — новая вершина становится корнем дерева.

### Входные данные

Входные данные содержат описание двоичного дерева.

В первой строке файла находится число `n` (`0 ≤ n ≤ 2⋅10⁵`) — число вершин в дереве.  
В последующих `n` строках файла находятся описания вершин дерева.  
В (`i+1`)-ой строке файла (`1 ≤ i ≤ n`) находится описание `i`-ой вершины, состоящее из трех чисел `Kᵢ`, `Lᵢ`, `Rᵢ`, разделенных пробелами — ключа в `i`-ой вершине (`|Kᵢ| ≤ 10⁹`), номера левого ребенка `i`-ой вершины (`i < Lᵢ ≤ n` или `Lᵢ = 0`, если левого ребенка нет) и номера правого ребенка `i`-ой вершины (`i < Rᵢ ≤ n` или `Rᵢ = 0`, если правого ребенка нет).

Все ключи различны. Гарантируется, что данное дерево является корректным АВЛ-деревом.

В последней строке содержится число `X` (`|X| ≤ 10⁹`) — ключ вершины, которую требуется вставить в дерево. Гарантируется, что такой вершины в дереве нет.

### Выходные данные

Выведите в том же формате дерево после осуществления левого поворота.  
Нумерация вершин может быть произвольной при условии соблюдения формата. Так, номер вершины должен быть меньше номера ее детей.

### Примеры

---

**STDIN**
```c++
2
3 0 2
4 0 0
5
```

**STDOUT**
```c++
3
4 2 3
3 0 0
5 0 0
```

---

## D. Очистка телефона

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

У Пети в телефоне записаны номера друзей. Однажды Петя заметил, что у него кончается свободная память на устройстве. Петя знал, что среди его контактов есть множество дубликатов. Он решил удалить повторяющиеся записи.

Каждый контакт — это строка, состоящая исключительно из строчных или заглавных букв латинского алфавита и цифр. При удалении строки освобождается `M` байт памяти, где `M` — количество различных символов в данной строке. Помогите Пете узнать, сколько памяти в байтах он сможет освободить.

### Входные данные

В первой строке входных данных дается число `n` (`1 ≤ n ≤ 10⁵`) — количество контактов в телефоне.

В следующей строке записаны через пробел `n` строк (`1 ≤ sᵢ ≤ 10⁴`) — контакты Пети.

### Выходные данные

Выведите одно число — ответ на задачу.

### Примечание

Решения, написанные при помощи **сортировок**, **бинпоиска** или **встроенных деревьев**, структур данных **set**, **map** и прочих — не засчитываются.


### Примеры

---

**STDIN**
```c++
5
qqwe qqwe abc s s
```

**STDOUT**
```c++
4
```

---

## E. Три друга 2: возвращение

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Три друга списывают лабораторную работу, каждый из них списывает по `n` различных задач. Поскольку друзья не очень умные, они не меняют названия отправляемых на проверку файлов.

По истечении времени, отведенного на написание лабораторной, преподаватель запускает бан-машину и ставит баллы по следующим правилам:

- если задача написана только у одного студента, то этот студент получает **3 балла**, поскольку эту задачу он не списывал и не давал списывать;
- если задача списана ровно у двух студентов, то каждый из них получает по **1 утешительному баллу**;
- если задача списана всеми тремя студентами, то за нее баллы **не начисляются никому**.

Выведите финальное количество баллов у каждого студента.

В рамках этой задачи будем считать, что Бан-машина считает решения списанными, если у них полностью совпадают имена файлов.

### Входные данные

В первой строке входных данных дается число `n` (`1 ≤ n ≤ 100000`) — количество задач в лабораторной.

Следующие три строки содержат по `n` различных слов в каждой — названия файлов с решениями, отправленных каждым из студентов.

### Выходные данные

Необходимо вывести **3 числа** — количество баллов у первого, второго и третьего студента соответственно.

### Примеры

---

**STDIN**
```c++
3
fir sec thi
thi fir sec
aaa sec bbb
```

**STDOUT**
```c++
2 2 6
```

---

### Примечание

Решения, написанные при помощи **сортировок**, **бинпоиска** или **встроенных деревьев** не засчитываются. **Set**, **Map** и т.п. — запрещены.

***В реальности бан-машина работает намного сложнее ;)***

---

## F. Детектив

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

В городе `N` произошла серия преступлений, расследовать которую пригласили опытного детектива Шерлока Толмса. Он с радостью принялся за новое интересное дело, но не учел, что в этот раз улик оказалось слишком много, и все они имеют совершенно разный "вес" для проведения расследования.

Шерлок нашел в телефонной книжке номер самого талантливого программиста в городе, которым оказались Вы, и обратился за помощью. Обладая знаниями алгоритмов и структур данных и проанализировав ситуацию, Вы решили хранить все зацепки в виде **АВЛ-дерева**, чтобы при необходимости достаточно быстро находить любой объект, при этом учитывая вес каждого свидетельства.

Во время расследования дела, Вам предстоит не только добавлять новые улики, но и удалять те, которые уже потеряли актуальность, а также проверять наличие определенных улик. К сожалению, не все знают как работает АВЛ-дерево, поэтому коллеги попросили Вас выводить **баланс дерева после каждой операции вставки и удаления**.

### Входные данные

В первой строке находится число `n` (`1 ≤ n ≤ 2 * 10⁵`) — число операций. Изначально улик нет. В каждой из последующих `n` строк находится описание одной из трёх операций:

- `A x` — поместить улику с весом `x` в дерево. Если она уже была добавлена, операция игнорируется.


- `D x` — удалить потерявшую актуальность улику, которая имеет вес `x`. Если такой нет, операция игнорируется.


- `C x` — проверить наличие улики с весом `x`.

### Выходные данные

Для каждой операции вида `C x` выведите `Y`, если такая улика содержится в дереве, и `N`, если не содержится.

Для каждой операции вида `A x` или `D x` выведите **баланс корня дерева после выполнения операции**.

Если дерево пустое (в нём нет вершин), выведите `0`.

Вывод для каждой операции должен содержаться на отдельной строке.

### Примеры

---

**STDIN**
```c++
6
A 3
A 4
A 5
C 4
C 6
D 5
```

**STDOUT**
```c++
0
1
0
Y
N
-1
```

---

### Примечание

При удалении необходимо менять удаляемое с максимальным элементом из левого поддерева.

---