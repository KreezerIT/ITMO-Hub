## A. АРАТАКИ РЕЙГЕН

- Лимит времени: **500 мс**
- Лимит памяти: **128 мб**

Его зовут Кагеяма Шигео. Его прозвище — Моб. Он настоящий экстрасенс, ученик **ВЕЛИЧАЙШЕГО ЭКСТРАСЕНСА 21 ВЕКА РЕЙГЕНА АРАТАКИ**. На его лице вы вряд ли увидите эмоции, но за таким неприметным парнишкой стоит огромная сила. Иногда, когда эмоции переполняют Моба, он выпускает всю свою экстрасенсорную неконтролируемую силу наружу и может навредить людям вокруг.

Но я, **Великий учитель Моба РЕЙГЕН АРАТАКИ**, научил Моба своему невероятному приёму:

Секретное очищающее зло экстрасенсорное изгнание **кодом Прюфера**  
(*プルーファーコードによる秘密の浄化邪悪な精神的な追放*)

Его суть проста, может даже вы, смертные, сможете его освоить. Я рисую Мобу дерево, а он превращает его в последовательность чисел.

### Входные данные

В первой строке два числа `n` (`3 ≤ n ≤ 5⋅10⁵`) — количество вершин в дереве, `m` — количество рёбер в дереве.  
Далее идут `m` (`2 ≤ m ≤ 5⋅10⁵`) строк с описанием рёбер, в каждой из которых по два числа `u`, `v` (`1 ≤ u, v ≤ n`).

### Выходные данные

Выведите `n−2` чисел — код Прюфера дерева.

### Примеры

---

**STDIN**
```c++
5 4
1 2
2 3
3 5
4 3
```

**STDOUT**
```c++
2 3 3
```

### [Решение](A.cpp)

---

## B. Истребители демонов

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Наших трех героев - Камабоко Гонпачиро, Зеницу и Иноске отправили на задание: им необходимо победить опасного демона - 6 высшую луну.

Герои шли по мрачному лесу, прислушывались к посторонним звукам, и вдруг Танджиро учуял отвратительный запах демона. Это могло значить только одно: команда идёт в нужном направлении. Они ускорились и побежали вслед за источником запаха.

Вскоре герои увидели разрушенную деревушку, из которой доносились душераздирающие крики. Стало понятно, что в этом замешан демон прошлого - ёкай, который лакомится людьми.

Теперь появилась задача сильно важнее уничтожения демона: спасение людей, которые прятались по своим домам и от страха не могли даже шагу сделать. Наша команда решила, что лучшим решением будет увести всех выживших в безопасное место.

Герои просят вашей помощи: найдите такую комбинацию дорог, следуя по которым они смогут посетить все дома и следовательно увести всех жителей (суммарная протяженность всех тропинок должна быть минимальной).

### Входные данные

В первой строке даны два натуральных числа `N` и `M` – количество домов и тропинок между ними соответственно (`3 ≤ N ≤ 100`, `N ≤ M ≤ N(N−1)/2`)

В каждой из следующих `M` строк находятся по три целых числа: `Aᵢ`, `Bᵢ`, `Cᵢ`, где `Cᵢ` – протяженность дороги между домами `Aᵢ` и `Bᵢ`  
(`1 ≤ Cᵢ ≤ 100000`; `i = 1, 2, … , N`).

### Выходные данные

Выведите одно число — минимальную суммарную протяженность всех дорог в найденной комбинации.

### Примеры

---

**STDIN**
```c++
4 4
1 2 1
2 3 2
3 4 5
4 1 4
```

**STDOUT**
```c++
7
```

### [Решение](B.cpp)

---

## C. Ведьмина служба доставки

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Кики — юная ведьма, которой только исполнилось 13 лет, и вскоре в её жизни начнётся новый важный этап: девочке предстоит стажировка. Она проведёт целый год вдали от дома, в Корико, где придётся жить за счёт предоставления горожанам своих профессиональных ведьминских услуг.

Как оказалось, Кирико — огромный мегаполис, и разбираться в устройстве всех его запутанных улочек — та ещё морока. Времени до переезда остаётся всё меньше и меньше, поэтому Кики старается распланировать всё до мельчайших подробностей. Волшебница уже собрала все баночки, скляночки, все магические травы и книжки, всё необходимое для любимого котёнка, но вот незадача, как же рассказать всем жителям Кирико о своих услугах?

Нашей юной ведьме сильно повезло, ведь в том городе у неё был знакомый картограф, и как только он узнал, что Кики собирается провести целый год в Корико, незамедлительно отправил ей карту города: он изобразил все дома, все связывающие их дороги, и для каждой указал протяженность. Безусловно, разбираться в этой запутанной схеме самостоятельно невозможно, да ещё и успеть всё до поездки... Кики снова обратилась за помощью. Девочка хочет **найти в этом городе такой маршрут, который позволит ей обойти всех жителей, и при этом он должен быть минимальным из возможных**. Помогите юной волшебнице справиться с этой задачей.

### Входные данные

В первой строке содержатся два числа: `N` и `M` — количество домов и дорог между ними соответственно  
(`3 ≤ N ≤ 10⁵`, `M ≤ 10⁶`).

В следующих `M` строках содержится по три числа: `aᵢ`, `bᵢ`, `lᵢ`, где  `aᵢ` и `bᵢ` — дома, которые соединяет `i`-ая дорога, а `lᵢ` — её протяженность  
(`1 ≤ lᵢ ≤ 10⁵`).

### Выходные данные

Выведите одно число — минимальную протяженность маршрута, который позволит Кики обойти все дома.


### Примеры

---

**STDIN**
```c++
4 4
1 2 1
2 3 2
3 4 5
4 1 4
```

**STDOUT**
```c++
7
```

---

### Примечание

Даже ксли Кики придётся пройти по какой-либо дороге дважды, чтобы посетить все дома, её протяженность всё равно учитывается лишь один раз.

### [Решение](C.cpp)

---

## D. Очень яблок хочется...

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Последнюю неделю Рюк только то и делал, что мечтал о яблоках, но как он ни старался их найти, у него всё никак не получалось. Ежедневно он ходил в 2–3 овощные лавки, после чего возвращался домой, но то он приходил туда слишком поздно, и все яблоки уже раскупали, то слишком рано, когда их ещё не успели завести. Любимых фруктов там никогда не было, да и магазинов в городе сильно больше. Вдоль каждой дороги между домами можно найти хотя бы одну, пусть даже крохотную, овощную лавку.

Рюк уверен, что ему точно удастся найти яблоки, если он **пойдет по маршруту, который позволит ему обойти все `M` дорог города**. **При этом он хочет начать свой путь дома и закончить там же**. Помогите Рюку заполучить желанные яблоки.

### Входные данные

В первой строке содержатся два числа: `N` и `M` — количество домов в городе и дорог, соединяющих их, соответственно (`1 ≤ N ≤ 5⋅10⁵`, `0 ≤ M ≤ 2⋅10⁵`).

Далее следуют `M` строк, содержащих два числа: `aᵢ` и `bᵢ` — описание `i`-ой дороги, которая соединяет дома `aᵢ` и `bᵢ`.

### Выходные данные

В одной строке выведите номера домов в том порядке, в котором их пройдёт Рюк. Если такого маршрута не существует, Рюк очень расстроится, выведите `:(`


### Примеры

---

**STDIN**
```c++
5 6
1 3
4 3
4 5
2 5
2 4
4 1
```

**STDOUT**
```c++
1 3 4 5 2 4 1
```

---

**STDIN**
```c++
4 5
3 2
1 2
2 4
3 1
4 3
```

**STDOUT**
```c++
:(
```

---

### Примечание

Рюк живёт в доме под номером 1.

Когда существует несколько верных вариантов выбрать верную дорогу, Рюк предпочитает выбирать дорогу с **меньшим номером** (номер дороги - её порядковый номер во входных данных).

### [Решение](D.cpp)

---

## E. Грязные делишки

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Пришел в замок дух помоек, и поручили Тихиро позаботиться о нем. Она сразу поняла, что обычной ванны недостаточно, чтобы очистить его, и нужно будет приготовить настой. Чтобы его приготовить, необходимо найти специальную табличку и отправить её господину Камадзи.

Замок устроен таким образом, что все переходы из комнаты в комнату представляют собой крутые и скользкие лестницы. Тихиро находится в комнате `a`, а нужная ей табличка в комнате `b`. Для того, чтобы сделать настой, ей надо добежать до комнаты `b` и вернуться обратно (отправить табличку она сможет только из комнаты `a`). Но вот незадача, дух помоек решил везде ходить за ней, а после того как он прошёл по лестнице, снова по ней пройти было уже невозможно из-за количества грязи, которое осталось после него.

Помогите Тихиро найти ответы на `Q` вопросов: выяснить, **сможет ли она при таком расположении комнат `a` и `b` найти табличку** и отправить её господину Камадзи.

### Входные данные

В первой строке даны три целых числа: `N` — максимальный номер комнаты в замке (нумерация комнат начинается с нуля, их количество — `N+1`), `M` — количество лестниц между ними, `Q` — количество запросов  
(`1 ≤ N ≤ 10³`, `1 ≤ M ≤ 10⁶`, `0 ≤ Q ≤ 10⁵`).

В следующих `M` строках находятся описания лестниц: `x` и `y` — номера комнат, между которыми есть лестница  
(`0 ≤ x`, `y ≤ N`, `x ≠ y`)

В следующих `Q` строках даны два целых числа: `a` — номер комнаты, в которой находится Тихиро, и `b` — номер комнаты, в которой лежит нужная табличка  
(`0 ≤ a`, `b ≤ N`).

### Выходные данные

На каждый вопрос Тихиро выведите `YES`, если она сможет найти табличку и отправить её дедушке Камадзи, и `NO`, если не сможет.


### Примеры

---

**STDIN**
```c++
5 7 5
0 2
0 3
0 4
0 5
1 2
2 3
2 5
0 2
4 5
1 3
2 4
2 5
```

**STDOUT**
```c++
YES
NO
NO
NO
YES
```

---

### Примечание

Гарантируется, что из каждой комнаты можно попасть в любую другую. Нумерация комнат начинается с нуля.

### [Решение](E.cpp)

---

## F. Результат двух миллионов лет работы

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Спустя 3 тысячи лет после каменной катастрофы, человечество потеряло цивилизацию. Молодой ученый Сенку, с которого довольно рано сошел каменный покров, нашел деревню, которая с нуля развивалась на протяжении 3 тысяч лет. Перед ним стояла сложная задача: заставить людей, которые никогда не видели цивилизации, поверить в науку. Вместе с любопытным пареньком Хромом они решили, что должны вылечить жрицу этой деревни от смертельной болезни, приготовив антибиотик.

Сенку знал, как добыть все необходимые материалы и что с ними делать, но это долгий процесс, для которого требуется множество различных мастерских для обработки и работы с различного рода веществами. Все мастерские были построены недалеко от лабораторной и работа шла полным ходом, но из-за неаккуратности Хром уронил на траву опасный химикат, который быстро распространился по всей земле, где стояли мастерские. Из-за этого химиката ходить по траве теперь опасно.

Сенку дал 10 миллиардов процентов, что вы сможете **найти такой способ построить дороги между мастерскими, чтобы можно было свободно перемещаться между ними** (**из любой мастерской можно попасть в любую другую, не обязательно за одну дорогу**), при этом на строительство дорог вы потратите **как можно меньше материалов**.

### Входные данные

В первой строке даны два натуральных числа: `N` и `M` — количество мастерских и возможные прямые пути между ними соответственно  
(`3 ≤ N ≤ 100`; `N ≤ M ≤ N ⋅ (N − 1) / 2)`.

В каждой из последующих `M` строк находятся три целых числа: `Aᵢ`, `Bᵢ`, `Cᵢ`, где `Cᵢ` — количество материалов, которое потребуется для строительства дороги между мастерскими `Aᵢ` и `Bᵢ`  
(`1 ≤ Cᵢ ≤ 300`; `i = 1, 2, ..., N`).

### Выходные данные

Выведите два натуральных числа `S₁` и `S₂` — минимальные количества необходимых материалов, которые потребуются для того, чтобы построить различные дороги между мастерскими  
(`S₁ ≤ S₂`).

### Примеры

---

**STDIN**
```c++
5 8
1 3 75
3 4 51
2 4 19
3 2 95
2 5 42
5 4 31
1 2 9
3 5 66
```

**STDOUT**
```c++
110 121
```

---

### Примечание

Гарантируется, что существует хотя бы 2 различные схемы дорог.

### [Решение](F.cpp)

---

## G. Побег Поньо

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Маленькая рыбка Поньо живёт в подводном царстве вместе со своим отцом, могучим морским колдуном, на дне океана. Любопытная малышка мечтает сбежать оттуда, чтобы понаблюдать за людьми, а может даже самой стать человеком.

Прощаясь с родным домом, рыбка хочет посетить каждый из `N` подводных городков, связанных дорогами, и не обязательно единожды. Известно, что из каждого города подводного царства возможно попасть в любой другой.

Сделать это без затрат вряд ли получится, ведь в подводном царстве есть `K` охраняемых дорог, и, чтобы проплыть по ним, рыбке придётся заплатить `B` монеток за пропуск. При этом, заплатив, она может проплыть там сколько угодно раз.

Поньо знает ещё `M` дорог, которые никем не охраняются. Вдоль каждой из них раскидано `S` монеток. Кажется, именно над ними часто плавают люди. Отец рассказывал Поньо, что моряки считают эти места счастливыми и бросают в воду монетки на удачу.

Рыбке нужно составить такой план дорог, чтобы она смогла попасть в каждый город. Сейчас у неё есть некоторые накопления, но траты из них должны быть минимальными. Во время подготовки к путешествию она может собрать монетки с счастливых дорог, но тогда она не сможет вернуться на них во время прощания с домом, так как стражи могут заметить что-то неладное, это слишком опасно. Но если Поньо решит не собирать там монетки заранее, она сможет плавать там во время прощания с домом абсолютно бесплатно.

**Нужно составить для героини маршрут**: помните, что если она решила заранее собрать монетки вдоль "счастливой" дороги из города `A` в город `B` (до путешествия), она не может плавать там, прощаясь с домом. Попасть в `A` и `B` в этом случае можно только через другие дороги: охраняемые, либо счастливые, с которых героиня не собирала монетки ранее. Помогите Поньо исполнить свою мечту и **посчитайте, сколько монеток она потратит из своих накоплений**.

### Входные данные

Первая строка содержит три целых числа: `N`, `M`, `K` — количество городов, "счастливых" и охраняемых дорог подводного царства соответственно  
(`1 ≤ M, N, K ≤ 8⋅10⁵`).

В следующих `M` строках записано по три целых числа: `X`, `Y`, `Sₓᵧ` — номера городов, которые соединяет "счастливая" дорога, и количество монеток на ней  
(`1 ≤ X < Y ≤ N`, `0 ≤ Sₓᵧ ≤ 10⁹`).

В следующих `K` строках записано по три целых числа: `X`, `Y`, `Bₓᵧ` — номера городов, между которыми пролегает охраняемая дорога, и стоимость пропуска для этой дороги  
(`1 ≤ X < Y ≤ N`, `1 ≤ Bₓᵧ ≤ 10⁹`).

### Выходные данные

Программа должна вывести единственное число — минимальный размер затрат из личных сбережений рыбки Поньо на путешествие.


### Примеры

---

**STDIN**
```c++
6 3 3
2 5 2
3 6 10
3 4 6
1 4 4
1 6 3
1 2 5
```

**STDOUT**
```c++
2
```

---

**STDIN**
```c++
4 2 3
1 2 9
3 4 10
1 3 3
2 4 5 
2 3 2
```

**STDOUT**
```c++
0
```

---

### Примечание

**Пояснение к примерам**:

**Пример 1**: В этом случае выгодно собрать монетки вдоль "счастливой" дороги из города 3 в город 6, затем оплатить пропуск на охраняемые дороги из города 1 в города 6, 4 и 2. Тогда Поньо соберёт 10 монеток, а потратит 12, то есть всего 2 монетки из личных сбережений.

**Пример 2**: В этом случае выгодно собрать монетки вдоль "счастливой" дороги из города 1 в город 2, затем оплатить пропуск на охраняемые дороги из города 1 в город 3 и из города 2 в город 4. Тогда Поньо соберёт 9 монеток, а потратит 8, то есть 0 монеток из личных сбережений.

### [Решение](G.cpp)

---

## H. Мугивары

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

На Гранд Лайне из-за магнитных волн, создаваемых островами, обычный компас бесполезен. Но команда Мугивар нашла выход — они заполучили Лог Пос — особое устройство, которое указывает на остров, чьи магнитные волны он ловит. С помощью него и несложных вычислений Нами узнала, сколько островов вокруг них.

Также Нами, пробыв два года на небесном острове Погодии, узнала, что течения на Гранд Лайне не самые обычные. Профессор Хередас назвал их гипертечениями — они могут соединять сразу несколько островов, а не 2, как обычно. Из любого острова в гипертечении можно добраться до любого другого в этом же гипертечении за одно и то же время.

И вот настал час воспользоваться своими знаниями. Мугивары совершили подвиг в стране Вано и отправляются дальше, прямиком на остров Эльбаф. Но им нужно торопиться и **выбрать самый короткий путь** до него. Номер страны Вано на новой карте Мугивар — `1`.

### Входные данные

В первой строке даны три числа:
- `n` — количество островов (`1 ≤ n ≤ 10⁵`),
- `m` — количество течений (`0 ≤ m ≤ 2⋅10⁴`),
- `k` — номер острова Эльбаф (`1 ≤ k ≤ n`).

Далее следует `m` описаны течения, сначала подается:
- `sᵢ` (`2 ≤ sᵢ ≤ 10⁷`) — количество островов, соединённых этим течением,
- `tᵢ` (`0 ≤ tᵢ ≤ 10⁷`) — время, за которое Мугивары смогут проплыть по гипертечению,
- Далее на этой строке идут `sᵢ` номеров островов, которые входят в это течение.

### Выходные данные

Одно число `t` — минимальное время, за которое Мугивары доберутся от страны Вано до острова Эльбаф. В случае если добраться нельзя, выведите `-1`.


### Примеры

---

**STDIN**
```c++
5 3 5
3 7 1 2 3
3 11 2 4 5
4 4 2 3 4 5
```

**STDOUT**
```c++
11
```

---

### Примечание

Может существовать несколько течений, которые ведут на один и тот же остров за разное время.

### [Решение](H.cpp)

---

## I. Конан из Акацуки

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Конан знала, что за ней придёт Обито. И она готовилась. Ей предстояло кропотливо подготовить 600 миллионов взрывных печатей по особой технике. Чтобы сделать одну взрывную печать, ей нужно сделать `N` операций, после чего рассчитать количество чакры, которое понадобится для наполнения печати.

Изначально Конан берёт квадраты со стороной `1`. Операция заключается в том, что все 4 угла квадрата складываются к центру, образуя новый квадрат со стороной `1/2`. После чего этот квадрат берётся за новый, и Конан продолжает складывать его, пока не сложит `N` раз.

После выполнения всех операций Конан раскрывает печать обратно той же стороной, с которой начинала, и видит на ней линии сгиба. Каждую линию нужно напитать чакрой по-разному. Если бумага складывается наружу — изгиб нужно напитать чакрой ветра — футоном, а если внутрь — чакрой огня — катоном.

После Конан вычисляет сумму длин всех напитанных футоном изгибов — `F` и напитанных катоном изгибов — `K`. Находит баланс чакры, который высчитывается как `F/K`.

Обито серьёзный противник, поэтому Конан нужно точно оценить силу печати. За свою жизнь она сделала достаточно много печатей и заметила, что баланс чакры можно представить в виде `A + √(2)·B`, где `A` и `B` — рациональные числа. А само `B` можно представить в виде несократимой дроби `p/q`, сила печати рассчитывается по формуле: ```(p · inv(q)) mod 999999893```, где `inv(q)` — [обратный по модулю](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) к `q`.

### Входные данные

Одно число `N` — количество операций, которые совершит Конан.  
(`0 ≤ N ≤ 10⁴`)

### Выходные данные

Одно число — сила печати.

### Примеры

---

**STDIN**
```c++
3
```

**STDOUT**
```c++
714285638
```

---

## J. А где Канеки?

- Лимит времени: **1000 мс**
- Лимит памяти: **256 мб**

Спецподразделение 11-го района готовится к штурму цитадели Аогири. От полиции поступила информация, что в какой-то из комнат может находиться Кен Канеки, но чтобы найти его, придётся обойти все помещения.

Участникам штурма удалось найти старый план здания, и на нём указаны все комнаты и связывающие их коридоры. Проходя по коридору впервые, штурмовики тратят `wᵢ` времени на его изучение, но возвращаясь туда вновь, они преодолевают его почти что молниеносно, ведь он им уже знаком. Придётся обходить комнаты настолько быстро, насколько это вообще возможно.

Но вот незадача, план мог устареть, так как в штабе Аогири могли разрушить некоторые коридоры, чтобы обезопасить себя и запутать потенциальных штурмовиков. Но узнать, какие именно коридоры разрушены, никак невозможно.

Спецподразделение просит вашей помощи! Для каждого коридора нужно найти минимальное время, за которое они сумеют проверить все комнаты, при этом гарантированно пройдя по нему.

### Входные данные

В первой строке записаны два числа `n` и `m` — количество комнат и коридоров в цитадели Аогири.  
(`1 ≤ n ≤ 2⋅10⁵`, `n−1 ≤ m ≤ 2⋅10⁵`)

В каждой из следующих `m` строк записаны три целых числа `uᵢ`, `vᵢ`, `wᵢ`:

(`1 ≤ uᵢ, vᵢ ≤ n`, `uᵢ ≠ vᵢ`, `1 ≤ wᵢ ≤ 10⁹`) — комнаты, соединённые `i`-м коридором, и время, за которое можно осмотреть этот коридор.

### Выходные данные

Необходимо вывести `m` строк:

`i`-ая строка содержит минимальное время, которое необходимо, чтобы обойти все комнаты, гарантированно осмотрев `i`-ый коридор.

То есть для первого коридора выводится минимальное время, которое потребуется для обхода всех комнат, если гарантировано осмотреть его, и так далее.

### Примеры

---

**STDIN**
```c++
5 7
1 2 3
1 3 1
1 4 5
2 3 2
2 5 3
3 4 2
4 5 4
```

**STDOUT**
```c++
9
8
11
8
8
8
9
```

---

**STDIN**
```c++
10 17
2 1 32094
4 3 10111
6 5 5172
8 7 19836
10 9 8543
7 10 11765
10 3 6696
3 5 31803
9 5 2536
10 4 26347
8 2 25300
10 8 2900
9 8 30644
10 2 9119
9 1 31391
8 6 9501
6 7 8951
```

**STDOUT**
```c++
86122
85419
85419
96304
85419
88233
85419
108679
85419
101655
101600
85419
107520
85419
85419
86377
85419
```

---

### Примечание

- По коридорам можно перемещаться в любом направлении.
- Гарантируется, что из каждой комнаты можно попасть в любую другую.
- Не существует такого коридора, который ведёт из комнаты `A` в неё же.
- Не существует двух или более различных коридоров, соединяющих одни и те же комнаты.
- В суммарном времени учитывается только первый проход по каждому коридору.

---