## A. Ярмарка судьбы

- Лимит времени: **1000 мс**  
- Лимит памяти: **128 мб**

Давным-давно, во времена древнего Египта, Сешат, богиня судьбы и счёта, решила установить новый порядок в распределении титулов между людьми. Она объявила, что каждый должен принести в храм Хатшепсут подношение, соответствующее тому титулу, который он хочет получить.

В назначенный день с самого утра приходили люди толпами в храм, принося с собой цветы, фрукты, хлеб и дары из драгоценных металлов. Все они были одеты в свои лучшие наряды, чтобы получить расположение со стороны Сешат.

Богиня, облачившись в пантеру, пришла в Хатшепсут. Увидев количество и разнообразие даров, принесённых почитателями, Сешат поняла, что не сможет точно расставить их от "лучшего" к "худшему". Вместо этого она решила сравнить `M` пар подарков и среди них выявить тот, который нравится ей больше.

По итогам такого попарного сравнения богиня распределила титулы таким образом, что индекс титула человека с лучшим подарком в паре был всегда больше индекса титула человека с худшим.

### Входные данные

В первой строке входного файла даны два натуральных числа `N` — количество даров, лежащих в храме, и `M` — количество сравнённых пар подношений (`1 ≤ N, M ≤ 10⁵`).

Далее в `M` строках перечислены пары подарков (`i, j`), среди которых `i`-тый подарок понравился богине меньше, чем `j`-тый. Гарантируется, что в графе, состоящем из рёбер `i → j`, нет циклов.

В следующих `q` строках содержатся запросы вида `a b`, указывающие в каком направлении необходимо двигаться по ветвям.

### Выходные данные

Для каждого подарка выведите индекс титула человека, принесшего его, после распределения Сешат.


### Примеры

---

**STDIN**
```c++
6 6
1 2
3 2
4 2
2 5
6 5
4 6
```

**STDOUT**
```c++
4 5 3 1 6 2
```

### [Решение](A.cpp)

---

## B. Месть Менады

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Выгнав одну неприметную менаду из своих войск, Дионис даже представить не мог, насколько жестокой может быть её месть. Вакханки всегда были близки к своему покровителю, поэтому каждая из них точно знала, как может ранить его больнее. Дионис не рассчитывал, что кто-либо из них решится на подобное, но менада Энанта после изгнания была готова на всё, лишь бы отомстить Дионису.

И вот одним ужасным днём, прогуливаясь по виноградникам, Дионис вдруг замечает, что часть из них покрылась странной чёрной материей. Она буквально обволакивала плоды и никак не хотела от них отходить. Богу сразу стало ясно, что произошло: Энанда, увлекавшаяся ботаникой, решила отомстить ему, заразив любимый виноградник. Именно здесь давным давно погиб Ампел, ставший виноградной лозой.

Дионис понимал, что медлить нельзя, нужно срочно выявить причину этой странной болезни виноградной лозы. Сквозь бури, дождь и грозы мчались к нему лучшие ботаники со всей Греции. Изучив заражение, они поняли, что болезни подвержены лишь ветви, образующие **цикл**. При том распространяется болезнь по веткам способна **только в одном направлении**.

Проверить каждую ветку вручную почти что невозможно, поэтому ботаники обратились к вам. Они изобразили растение в виде графа и теперь отправляют вам `q` запросов вида `a b`, на каждый из которых необходимо вывести `YES`, если **двигаясь по веткам в заданном направлении из грозди `a` в гроздь `b` возможно затем вернуться в гроздь `a`**, и `NO` в противном случае.

### Входные данные

- В первой строке содержатся целые числа `n`, `m`, `q` (`1 ≤ n, m, q ≤ 10⁶`), где n — количество гроздей винограда, m — количество ветвей, q — количество запросов.


- В следующих `m` строках содержатся пары чисел `start`, `end` (`1 ≤ start, end ≤ n`), описывающие направленные ветви (болезнь может распространяться лишь по направлению из города `start` в гроздь `end`).


- Далее идут `q` строк, в каждой из которых два числа `a`, `b` (`1 ≤ a, b ≤ n`) — запрос.

### Выходные данные

В `q` строках выведите:

- `YES`, если, двигаясь по веткам в заданном направлении из грозди `aᵢ` в гроздь `bᵢ`, можно затем вернуться в гроздь `aᵢ`;
- `NO` в противном случае.

### Примеры

---

**STDIN**
```c++
7 8 5
1 2
2 3
3 4
4 5
5 1
5 6
6 7
7 6
1 4
5 6
6 7
2 5
1 7
```

**STDOUT**
```c++
YES
NO
YES
YES
NO
```

### [Решение](B.cpp)

---

## C. Порванное ожерелье

- Лимит времени: **1000 мс**
- Лимит памяти: **512 мб**

Четыре гнома Брисинга создали ожерелье невероятной красоты и назвали его Брисингамен. Ожерелье состояло из  
`N` бусин и было создано таким образом, что любые две бусины могли быть связаны друг с другом несколькими нитками, а также любая бусина может быть оплетена ниткой (по сути связана с самой собой).

Однажды богиня любви Фрейя гуляла по лесу и набрела на пещеру, где эти четыре гнома сидели и любовались своим творением. Увидев столь невероятное украшение, девушка тотчас же захотела заполучить его. Но гномы согласились отдать его, только если Фрейя одарит каждого из них своим вниманием.

Спустя некоторое время, богиня вернулась в свой замок Фолькванг уже с ожерельем. Верховный бог Один, возлюбленный Фрейи, узнав о случившемся, разгневался и приказал Локи выкрасть Брисингамен. Ночью Локи, превратившись в блоху, пробрался в покои богини и сумел снять с неё украшение. Когда Локи убегал оттуда с Брисингаменом, Хеймдалль, страж "радужного моста" между миром людей и миром асов, увидел воришку, погнался за ним и схватился за ожерелье. Под натяжением часть ниток, скреплявших бусины, порвалась.

Локи и Хеймдалль решили восстановить украшение. Для этого им нужно понять, сколько фрагментов ожерелья всё ещё крепко связаны. Фрагмент ожерелья **считается крепко связанным**, если у каждой бусины во фрагменте есть бусина из этого же фрагмента, к которой она присоединена, либо она одна в этом фрагменте.

### Входные данные

В первой строке два целых числа `N` — количество бусин, `M` — количество сохранившихся связей между бусинами  
(`0 ≤ N ≤ 10⁵`, `0 ≤ M ≤ 10⁶`).

В следующих `M` строках даны пары чисел (`i, j`), описывающие связь между `i`-той и `j`-той бусиной  
(`1 ≤ i, j ≤ N`).

### Выходные данные

Выведите количество крепко связанных фрагментов ожерелья.


### Примеры

---

**STDIN**
```c++
4 2
1 2
3 1
```

**STDOUT**
```c++
2
```

### [Решение](C.cpp)

---

## D. Песня Сирин

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

Ворожей наш новости принёс. В лесу птица Сирин запела, дурной знак. Время тёмное грядет, Чернобог беду ведёт на Русь-матушку. Нежить вся с могил встаёт, кошки по углам прячутся, сила нечистая биться собирается.

Деревня вся наша напугана, не знает что делать. Но выручил нас ворожей. Говорит руны нанести надо, солью их соединив. На семью каждую нужно по руне. Правда осторожным быть надобно, по дорогам некоторым ходить в одну сторону можно только, иначе Лешего разгневаем.

Поручил Ворожей вам руны нанести от мала до велика, объяснив, что Семьёй называть будем дома, что из любого дома семьи можно попасть в любой другой дом этой семьи. Семьи номер указал называть наименьшим номером дома этой семьи. Меж семьями тропинка есть тогда лишь, когда дорога хоть одна есть меж любым домом из семьи этой и любым домом из семьи иной.

### Входные данные

В первой строке два целых числа даны: домов в деревне количество `N` (`N ≤ 10⁷`) и тропинок в деревне количество `M` (`M ≤ 10⁷`).

Следующие `M` строк держат по два целых числа `a` — номер дома, откуда путь держат и `b` — номер дома, куда путь ведёт.

### Выходные данные

В первой строке необходимо вывести количество семей, а также количество дорог между семьями.

Во второй строке необходимо вывести все дороги в виде двух целых чисел `a` — номер семьи, откуда путь держат и `b` — номер семьи, куда путь ведёт.


### Примеры

---

**STDIN**
```c++
5 6
1 4
1 5
2 3
3 2
4 3
5 1
```

**STDOUT**
```c++
3 2
1 4
4 2
```

---

**STDIN**
```c++
3 2
1 2
2 1
```

**STDOUT**
```c++
2 0
```

---

### Примечание

Полученные набор дорог необходимо сначала отсортировать по домам, в которых дорога начинается, затем по домам, в которых она заканчивается

### [Решение](D.cpp)

---

## E. Беги и не возвращайся

- Лимит времени: **1000 мс**
- Лимит памяти: **256 мб**

У подножия горы Митаке стоит небольшой с виду ничем не примечательный храм. Но если присмотреться, то можно увидеть статую маленького лисёнка, стояющую на крыше храма.

Раньше за храмом следил молодой монах. Все из деревни поблизости ходили к нему за лечением. Однажды в лесу нашли маленькую спящую девочку и принесли её в храм. Когда девочка проснулась она тут же обернулась маленьким лисёнком.

Монах сразу понял в чём дело, это был детёныш кицуне - лисы оборотня. Монах назвал девочку Мицуко и сказал не показываться никому в облике лисы. В деревне все знали легенду об обманщице кицуне, которая владеет тёмной магией.

Годы шли, Мицуко стала жрицей храма, по ночам она уходила на охоту в лисьем облике, а днём лечила жителей деревни. Однажды случилась эпидемия, страшная хворь напала. Мицуко решила использовать свою магию, чтобы вылечить деревню и ей это удалось. Но, увы, хотя больный выздоравливали, суеверные жители села начали бояться Мицуко и рассказывать всем, что она хочет причинить им зло. Население, объятое страхом, сочло Мицуко виноватой в этой заразе и всех бедах, что случались с селом.

Испуганный народ пришёл к дверям храма, чтобы убить Мицуко. Монах преградил им путь, пытаясь убедить их, что у Мицуко доброе сердце. Внезапно кто-то из деревни воткнул копье в сердце монаха. Последнее, что Монах успел сказать: "Мицуко, беги и не возвращайся".

И Мицуко побежала, но напуганная Мицуко хотела забрать с собой душу монаха, для чего ей нужно было пробежать минимум две дороги, а потом вернуться назад. Мицуко может бежать по дороге в любую сторону, но по каждой дороге только один раз. Так как Мицуко владеет магией она может сделать храм любой их точек. Дорогой она называет путь между двумя точками.

### Входные данные

В первой строке через пробел даны два числа: `n` (`1 ≤ n ≤ 10⁶`) - количество точек и `m` (`1 ≤ m ≤ 5⋅10⁴`) - количество дорог.

Следующие `m` строк содержат по два целых числа `u`, `v` (`1 ≤ u, v ≤ n`) - описывающие пары точек в лесу, через которые может пробежать Мицуко.

### Выходные данные

Если Мицуко сможет забрать душу Монаха с собой, то выведите `YES`, иначе выведите `NO`.


### Примеры

---

**STDIN**
```c++
3 3
1 2
1 3
2 3
```

**STDOUT**
```c++
YES
```

---

**STDIN**
```c++
4 2
1 3
2 4
```

**STDOUT**
```c++
NO
```

### [Решение](E.cpp)

---

## F. Древняя карта архипелага

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

После знатного празднования свадьбы царя Арктона, Ясон и его сокомандники по поиску золотого руна отправились в сторону Босфора. В ночи их настиг сильный ветер. Утром они поняли, что на их пути теперь стоит архипелаг из `N` островов, а их корабль прибило к первому острову.

...

Вот на берег сошёл Ясон во главе своих аргонавтов,  
На скале кто-то добрый заранее оставил посланье:

«Острова, мореход, здесь один опасней другого:  
Тут и Лемнос, там женщины всех перебили мужей за измену.  
И Кизик, шестирукие где великаны разошлись не на шутку.  
На Мизии затащат героев в пучину нимфы речные.  
А в Вифинии царь - повелитель смертельных кулачных боев.  
Во Фракии хищные гарпии отнимают еду у Финея.  
Симплегадские скалы сдвигаются - смерть кораблям мореходов.  
А в Аретии птиц стимфалийских перья, как стрелы, из бронзы.»

И в пещере скалы той нашли аргонавты древнюю карту.  
Каждый остров на ней нумерован подробно и честно.  
И хотя на пути ожидалось препятствий немало,  
Всё же были лазейки между парами тех островов злополучных,  
Где проплыть кораблю за мечтою своей златорунной  
Было очень возможно и (на сердце руку) реально.

И к сему прилагался, ни много ни мало, пергаментный свиток,  
Пары чисел начертанных знаменовали номера островов,  
Где Ясон без препятствий пронесёт «Арго» меж волнами.  
А чего ради всё? А всё во имя любви!

...

Герои решили последовать совету из письма и передвигаться исключительно в безопасных местах. Дорога между любыми двумя островами, перечисленными в письме, займёт один день. Ясон захотел выяснить, до каких островов их кратчайший путь займёт ровно `K` дней.

### Входные данные

В первой строке дано целое число `N` — количество островов (`0 ≤ N ≤ 10⁵`).

Во второй строке два целых числа `M` — количество пар островов, перечисленных в письме, `K` — количество дней (`0 ≤ M ≤ 10⁶`, `0 ≤ K ≤ M`).

Далее следует `M` строк, содержащих пары островов (`i, j`), между которыми могут переплывать герои (`1 ≤ i, j ≤ N`).

### Выходные данные

Выведите все острова, кратчайший путь до которых займёт ровно `K` дней. Если таких нет, выведите `NO`.


### Примеры

---

**STDIN**
```c++
6
5 2
1 2
1 4
4 5
4 3
3 6
```

**STDOUT**
```c++
3
5
```

### [Решение](F.cpp)

---

## G. Левитирующие сады Семирамиды

- Лимит времени: **3000 мс**
- Лимит памяти: **512 мб**

В далёком будущем на раскопках возле города Хилла, на бывшей территории Вавилона, были обнаружены останки "Висячих садов Семирамиды". Гуманитарные технологи города решили восстановить их и сделать новым туристическим местом.

Восстановить сами сады оказалось не такой уж и трудной задачей. Кроме того, их получилось сделать по-настоящему левитирующими. Главной сложностью оказалось обеспечить регулярный полив всех растений.

В начале VII века до н.э. использовалась технология "Архимедовы винты", где основную функцию поставки воды выполняли рабы. Технологи решили автоматизировать этот полив с помощью дронов. Всего есть  
`K` левитирующих растений, каждое из которых задаётся координатами основания (`xᵢ`, `yᵢ`, `zᵢ`) и высотой `hᵢ` (высота считается включая основание). Земля находится в плоскости (`x`, `y`, 0).

Для полива очередного растения, дрону необходимо добраться из точки (`xₛ`, `yₛ`, `zₛ`), в точку (`xƒ`, `yƒ`, `zƒ`). Однако дрон не должен повредить растения, соответственно он не может пролетать сквозь них. Аккумулятор дрона вмещает только  
`E` кВт энергии (изначально он заряжен полностью). **Каждое движение дрона на 1 координату расходует ровно 1 кВт энергии**.

Ваша задача — определить минимальное количество энергии, которое потребуется дрону, для полива одного растения (т.е. для того, чтобы добраться из начальной точки в конечную), или вывести `−1`, если это невозможно.

### Входные данные

- Первая строка содержит два целых числа: `K` и `E`  
  (`0 ≤ K ≤ 10⁵`, `0 ≤ E ≤ 10⁶`) — количество растений и количество кВт энергии у дрона соответственно.


- Вторая строка содержит три целых числа: `xₛ`, `yₛ`, `zₛ`  
  (`1 ≤ xₛ, yₛ, zₛ ≤ 101`) — координаты точки старта дрона.


- Третья строка содержит три целых числа: `xƒ`, `yƒ`, `zƒ`  
  (`1 ≤ xƒ, yƒ, zƒ ≤ 101`) — координаты конечной точки дрона.


- Далее идут `K` строк, каждая из которых содержит четыре целых числа: `xᵢ`, `yᵢ`, `zᵢ`, `hᵢ`  
  (`1 ≤ xᵢ, yᵢ, zᵢ, hᵢ ≤ 101`) — координаты основания левитирующего растения и его высоту.

### Выходные данные

Выведите минимальное количество энергии, которое потребуется дрону, чтобы добраться из начальной точки в конечную, или `−1`, если это невозможно.

### Примеры

---

**STDIN**
```c++
0 100
1 1 1 
2 2 2
```

**STDOUT**
```c++
3
```

---

**STDIN**
```c++
0 0
1 1 1 
2 2 2
```

**STDOUT**
```c++
-1
```

---

**STDIN**
```c++
0 333899
51 17 97
55 45 12
```

**STDOUT**
```c++
117
```

---

**STDIN**
```c++
5 474616
100 32 80
59 58 30
100 77 64 1
31 14 4 2
39 34 86 1
3 1 84 1
50 31 71 1
```

**STDOUT**
```c++
117
```

---

### Примечание

Дрон может летать где хочет, если не задевает растения, соответственно во время полёта его координаты принадлежат `[0; +∞)`. В случае если начальная и конечная точка маршрута дрона совпадают, необходимо вывести `0`.

Действие задачи разворачивается в параллельной вселенной, где изобретатель-механик Джеймс Ватт решил, что энергия может измеряться в кВт.

---

## H. Амрита

- Лимит времени: **2000 мс**
- Лимит памяти: **256 мб**

Пятиликий бог, что предстал перед вами. Третий глаз на лбу и тысяча рук. Вы удостоились стать воплощением Шивы, но сначала нужно пройти его испытание, сварив амриту - снадобье бессмертия, что дарует вам силу.

Шива начал рассказывать вам рецепт, но каждый из ртов по-своему говорил, как нужно его сварить:

- Ишана говорил: `A || B`, вы обязаны добавить хотя-бы один ингредиент из `A` и `B`.


- Татпуруша говорил: `A -> B`, если вы добавили ингредиент `A`, то должны добавить ингредиент `B`.


- Садьоджата говорил: `A && B`, вы обязаны добавить оба ингредиента `A` и `B`.


- Вамадева говорил: `A ^ B`, вы обязаны добавить только один из ингредиентов `A` или `B`.


- Агзора говорил: `!A`, вы обязаны не добавлять ингредиент `A`.

При этом, если Шива ничего не говорит про ингредиент, то его можно взять. Кроме того, если по условиям Шивы зелье окажется без ингредиентов - его всё равно можно приготовить.

Вы станете воплощением Шивы, если вы сварите зелье или скажите, что это невозможно.

### Входные данные

В первой строке даны целые числа: `n` (`n ≤ 10⁶`) - количество ингредиентов и `k` (`k ≤ 10⁶`) - количество условий Шивы.  
Далее в `k` строках даны условия Шивы в виде `!A` или `A x B`, где `A` и `B` - номера ингредиентов (`1 ≤ A,B ≤ n`).

### Выходные данные

Если зелье невозможно сварить выведите `NO`.  
Если зелье возможно сварить выведите `YES`.

### Примеры

---

**STDIN**
```c++
2 3
!1
!2
1 ^ 2
```

**STDOUT**
```c++
NO
```

---

**STDIN**
```c++
3 2
1 || 2
2 -> 3
```

**STDOUT**
```c++
YES
```

---

## I. Гидра или не гидра, вот в чём вопрос...

- Лимит времени: **1000 мс**
- Лимит памяти: **128 мб**

— "Вон там, чуть выше Сириуса, видишь? Словно лошадь, но с рогом во лбу, удивительно!" — вскликнул Архимед. Последние часа два они с Евклидом только тем и занимались, что разглядывали звёзды, стараясь увидеть в соединениях точек знакомые образы.

— "А теперь глянь ещё чуть левее, чуть выше, видишь? Ну натурально гидра лернейская, восхитительно!" — радостно молвил Архимед.

— "Чего? Какая ещё гидра такая? Вовсе и не похоже!" — твердил Евклид.

— "Да ещё как похоже, ты вглядись просто" — стараясь убедить собеседника, говорил Архимед.

— "Слушай, ты, вероятно, не понял. Давай рассмотрим созвездие, которое ты гидрой обозвать пытаешься, как граф неориентированный, в котором `n` вершин и `m` рёбер. Если ты **сумеешь его представить как набор из трёх или более корневых деревьев**, корни которых простым циклом соединены, то твоя взяла, можешь гидрой обзывать" — сказал Евклид.

— "А как же я это доказать тебе смогу?" — спросил Архимед.

— "Что-то подсказывает мне, что веков так через 20 с лишним наш спор точно разрешат" — спокойно сказал Евклид, продолжая разглядывать звёзды.

### Входные данные

В первой строке содержатся два целых числа: `n` и `m` (`1 ≤ n ≤ 100`, `0 ≤ m ≤ n(n−1)/2`), где `n` — количество вершин, а `m` — количество рёбер графа созвездия.

В каждой из следующих `m` строк записаны пары целых чисел `x` и `y` (`1 ≤ x, y ≤ n`, `x ≠ y`), обозначающих существование ребра между вершинами `x` и `y` в графе.

### Выходные данные

Выведите `ARCHIMEDES`, если данный граф является гидрой, в противном случае выведите `EUCLID`.

### Примеры

---

**STDIN**
```c++
6 6
6 3
6 4
5 1
2 5
1 4
5 4
```

**STDOUT**
```c++
ARCHIMEDES
```

---

**STDIN**
```c++
6 5
5 6
4 6
3 1
5 1
1 2
```

**STDOUT**
```c++
EUCLID
```

---

### Примечание

Гарантируется, что граф не содержит кратных рёбер и петель.

**Простым циклом** назовём множество из `v` вершин, которые можно пронумеровать так, что будут существовать рёбра только между вершинами с номерами `1`и`2`, `2`и`3`, ... , `v−1`и`v`, `v`и`1`.

**Дерево** — связанный неориентированный граф из `n` вершин и `n−1` рёбер (`n > 0`).

**Корневое дерево** — дерево, в котором выделена одна вершина, корень.

### [Решение](I.cpp)

---

## J. Подвал Франкенштейна

- Лимит времени: **2000 мс**
- Лимит памяти: **128 мб**

За окном была тёмная густая ночь, но Виктор никак не мог сомкнуть глаз. В подвале его лаборатории уже всё было готово к оживлению монстра, но герой до сих пор не понимал, верно ли поступает. Тревога окутала Франкенштейна, и он начал перебирать самые страшные исходы.

Мысли Виктора заполонили вопросы: "Что если ничего не сработает? Если *он* не оживёт? В таком случае это станет огромным разочарованием, все мои старания в топку. А вдруг *он* сбежит? Вдруг захочет убивать людей? Нет, нет, я не могу такого допустить. Вдруг он захочет навредить Элизабет?!". Напуганный тем, что его же создание может навредить дорогой жене, учёный вскочил с кровати и помчался в лабораторию. Пробегая по запутанным подземным коридорам, он начал описывать вход в каждое помещение.

Монстр сможет попасть из одной комнаты в другую лишь если он сумеет протиснуться через i-ую дверь, то есть если его рост будет в промежутке `[lᵢ, rᵢ]`. Ещё не оживлённое тело чудовища находится в первой комнате, а выход, ведущий в дом, а следовательно дающий монстру возможность напасть на Элизабет, располагается в комнате под номером `n`. Виктор записал параметры всех проёмов и начал высчитывать максимальные размеры его творения, при которых то сумеет покинуть лабораторию. Перебирать все возможные варианты оказалось непросто, поэтому герой обратился за помощью к вам. Помогите ему найти количество всех возможных монстров, способных сбежать из подвала учёного (высота — целое число).

### Входные данные

В первой строке содержатся числа `n` и `m` (`1 ≤ n ≤ 10³`; `0 ≤ m ≤ 3∗10³`) — количество помещений в лаборатории и соединяющих их коридоров соответственно.

В следующих `m` строках содержатся пары чисел (`u, v`), описывающие лабораторию: `u, v` (`1 ≤ u, v ≤ n`; `u ≠ v`) — номера помещений лаборатории, которые связывает `j`-ый коридор.

Далее в `m` строках содержатся пары чисел `lᵢ rᵢ`, описывающие дверные проёмы: `lᵢ, rᵢ` (`1 ≤ lᵢ ≤ rᵢ ≤ 10⁶`) — размеры `i`-ого дверного проёма.

### Выходные данные

В единственной строке выведите количество всевозможных монстров Франкенштейна, для которых рост — целое число, способных покинуть лабораторию. Если ни одно чудовище не сможет попасть в `n`-ое помещение лаборатории, то выведите `−1`.

### Примеры

---

**STDIN**
```c++
6 6
1 2
2 3
3 6
1 4
4 5
5 6
1 10
1 10
1 1
1 4
1 3
1 3
```

**STDOUT**
```c++
3
```

---

**STDIN**
```c++
4 4
1 2
1 3
2 4
3 4
3 4
5 6
3 4
5 6
```

**STDOUT**
```c++
2
```

---

### Примечание

Обратите внимание, что все монстры из выбранного отрезка должны пройти по одному пути, а не по нескольким (смотри пример 2).

---