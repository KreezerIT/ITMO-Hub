# Билеты к экзамену

1. [Что такое виртуальная среда исполнения управляемого кода? Каковы отличия от неуправляемых языков?](#1-что-такое-виртуальная-среда-исполнения-управляемого-кода-каковы-отличия-от-неуправляемых-языков)
2. [Что такое спецификация языка? Отличия между основными изданиями Java. Приведите примеры набора API различных изданий.](#2-что-такое-спецификация-языка-отличия-между-основными-изданиями-java-приведите-примеры-набора-api-различных-изданий)
3. [Иерархия интерфейсов для работы с коллекциями. Особенности Stream API.](#3-иерархия-интерфейсов-для-работы-с-коллекциями-особенности-stream-api)
4. [Системы сборок, предназначение, ключевые особенности. Понятие модульности и конвенций иерархии пакетов.](#4-системы-сборок-предназначение-ключевые-особенности-понятие-модульности-и-конвенций-иерархии-пакетов)
5. [Автоматическое управление памятью. Алгоритмы очистки.](#5-автоматическое-управление-памятью-алгоритмы-очистки)
6. [Сборка мусора на поколениях. Устройство кучи. Принцип работы.](#6-сборка-мусора-на-поколениях-устройство-кучи-принцип-работы)
7. [Технологии Java EE для работы с данными. Популярные имплементации спецификации JPA.](#7-технологии-java-ee-для-работы-с-данными-популярные-имплементации-спецификации-jpa)
8. [Особенности реализации CDI в Spring. Внедрение зависимостей. Инверсия контроля.](#8-особенности-реализации-cdi-в-spring-внедрение-зависимостей-инверсия-контроля)
9. [Что такое «сервлет»? Отличия сервера приложений и контейнеров сервлетов.](#9-что-такое-сервлет-отличия-сервера-приложений-и-контейнеров-сервлетов)
10. [Жизненный цикл запроса в рамках DispatcherServlet в Spring.](#10-жизненный-цикл-запроса-в-рамках-dispatcherservlet-в-spring)
11. [Основные задачи решаемые с помощью Spring Boot. С помощью каких инструментов достигается результат?](#11-основные-задачи-решаемые-с-помощью-spring-boot-с-помощью-каких-инструментов-достигается-результат)
12. [Инструменты и типовые решения для аутентификации и авторизации запросов.](#12-инструменты-и-типовые-решения-для-аутентификации-и-авторизации-запросов)
13. [Парадигма аспектно-ориентированного программирования. Отличия от ООП.](#13-парадигма-аспектно-ориентированного-программирования-отличия-от-ооп)
14. [Межсервисное взаимодействие. Микросервисная архитектура.](#14-межсервисное-взаимодействие-микросервисная-архитектура)
15. [Какие ключевые задачи решают брокеры сообщений? Перечислите известные вам модели обмена сообщениями и протоколы.](#15-какие-ключевые-задачи-решают-брокеры-сообщений-перечислите-известные-вам-модели-обмена-сообщениями-и-протоколы)
16. [Ключевые отличия Apache Kafka от RabbitMQ. Паттерн Outbox.](#16-ключевые-отличия-apache-kafka-от-rabbitmq-паттерн-outbox)


#### 1. Что такое виртуальная среда исполнения управляемого кода? Каковы отличия от неуправляемых языков?

> **Def:** **Виртуальная среда исполнения управляемого кода** — это программная платформа, обеспечивающая выполнение кода, который работает не напрямую на "железе", а через промежуточный слой, управляющий его безопасностью, памятью, потоками и другими ресурсами. Такой код называется _управляемым_

##### Управляемый и неуправляемый код

> **Def:** **Управляемый код (Managed Code)** — это код, который выполняется под управлением виртуальной среды исполнения. Все ресурсы (память, потоки, безопасность и др.) контролируются виртуальной машиной (JVM, CLR и др.).

> **Def:** **Неуправляемый код (Unmanaged Code)** — это код, который напрямую выполняется процессором без прослойки виртуальной машины (например, программы на C, C++, Assembler).

##### Отличия:

| Характеристика        | Управляемый код                                | Неуправляемый код                                       |
|-----------------------|------------------------------------------------|---------------------------------------------------------|
| Запуск                | Через виртуальную машину (JVM, CLR)            | Напрямую на процессоре                                  |
| Управление памятью    | Автоматическое (GC)                            | Ручное (malloc/free, new/delete)                        |
| Контроль безопасности | Проверка типов, защита памяти                  | Возможен произвольный доступ к памяти                   |
| Работа с потоками     | Поддержка внутри VM                            | Реализация OS/разработчик                               |
| Портируемость         | Высокая (работает везде, где есть VM)          | Требует перекомпиляции под платформу                    |
| Уровень контроля      | Меньше (абстрагируется от железа)              | Максимальный (полный контроль над ресурсами)            |
| Возможность ошибок    | Защищён от большинства ошибок работы с памятью | Возможны утечки, переполнения буфера, висячие указатели |
 Пример:
- **Управляемые языки**: Java, C#, Kotlin, Scala, JavaScript.
- **Неуправляемые языки**: C, C++, Assembler.

Именно благодаря виртуальной среде исполнения управляемый код безопасен, стабилен и кроссплатформенен, что делает его идеальным выбором для большинства современных приложений, особенно в корпоративной и серверной среде.
##### Работа управляемого кода
Высокоуровневые языки программирования часто не создают машинный код напрямую, а компилируют исходный код в _промежуточный язык_. Этот промежуточный код затем выполняется специальной виртуальной машиной, что позволяет обеспечить:

- Портируемость между платформами;
- Безопасность исполнения;
- Автоматическое управление памятью;
- Контроль типов и изоляцию процессов

> **Def:** В случае Java компилятор (javac) преобразует исходный код в **байт-код** — специальный промежуточный код, который исполняется виртуальной машиной Java (JVM)

> **Def:** **Байт-код Java** — это набор инструкций, которые интерпретирует или компилирует в машинный код виртуальная машина Java (JVM). Каждый код операции байт-кода занимает 1 байт (8 бит). Не все 256 возможных кодов задействованы — часть зарезервирована на будущее

JVM работает **и как интерпретатор, и как компилятор**, в зависимости от реализации и ситуации:
- В классическом смысле JVM **интерпретирует байт-код** — читает команды по одной и выполняет их на процессоре.
- Однако современные JVM (например, HotSpot) используют **JIT-компиляцию (Just-In-Time)** + Ahead Of Time компиляцию перед запуском программы — во время выполнения байт-код часто компилируется в нативный машинный код, который затем выполняется напрямую процессором. Это повышает производительность.

> **Def:** **Виртуальная машина Java (JVM)** — программная среда, которая исполняет байт-код. Именно благодаря JVM Java-программы могут выполняться на любой платформе, где установлена JVM. Она обеспечивает безопасность, управление памятью, потоками, исключениями, сборку мусора и прочее
##### Структура JVM

JVM включает в себя три основных компонента:

1. **Спецификация (JVM Specification)**  
Набор правил, определяющих, как должна работать JVM. Спецификация оставляет свободу реализации, но требует соблюдения стандартов корректного исполнения Java-программ (например, правильная интерпретация class-файлов, соблюдение типовой безопасности, корректная работа со стеком вызовов и т.д.)

2. **Реализация (Implementation)**  
Конкретная программа, реализующая спецификацию JVM. Существует множество реализаций:
- **HotSpot JVM** (самая распространённая — входит в OpenJDK и Oracle JDK),
- **OpenJ9 (IBM)**,
- **GraalVM**,
- **Azul Zulu**,
- **Amazon Corretto** и др

3. **Экземпляр JVM (Instance)**  
Конкретный запущенный процесс JVM на компьютере при выполнении программы. Например, при запуске игры Minecraft запускается экземпляр JVM, который исполняет байт-код программы

> **Def:** **JDK (Java Development Kit)** — комплект разработчика Java, включающий компилятор (javac), средства сборки, отладки и т.д.

> **Def:** **JRE (Java Runtime Environment)** — минимальная среда исполнения Java, включающая JVM и стандартные библиотеки классов для запуска Java-программ.



#### 2. Что такое спецификация языка? Отличия между основными изданиями Java. Приведите примеры набора API различных изданий.

> **Def:** **Спецификация языка программирования** — это официальное описание синтаксиса, семантики, правил поведения и стандартных библиотек языка, позволяющее разработчикам, и пользователям интерпретировать язык единообразно.
##### Спецификация Java
В Java спецификация разделяется на несколько ключевых частей:

1. **Java Language Specification (JLS)**  
Описывает синтаксис и семантику языка Java:
- правила записи программ;
- типы данных;
- ключевые слова;
- область видимости;
- правила наследования и полиморфизма;
- обработку исключений и др.

2. **Java Virtual Machine Specification (JVM Spec)**  
Описывает внутреннюю модель виртуальной машины Java:
- формат class-файлов;
- байт-код и его интерпретацию;
- модель памяти JVM;
- управление потоками;
- поддержка сборки мусора (GC).

3. **Java API Specification (Standard API)**  
Содержит описание всех стандартных библиотек, доступных в платформе Java:
- коллекции;
- ввод-вывод;
- работа с сетью;
- безопасность;
- многопоточность;
- стандартные классы (например, `String`, `List`, `Map`, `Thread`, `File`, `Socket` и др.).

4. **Реализации**  
Реальные программные реализации спецификации JVM и API:
- **OpenJDK** (базовая открытая реализация),
- **Oracle JDK**,
- **IBM OpenJ9**,
- **GraalVM** и др.
##### Связь спецификации и JVM

> **Def:** Спецификация JVM — это часть общей спецификации Java, определяющая, как должна работать виртуальная машина Java. Она даёт разработчикам свободу выбора реализации, но при этом гарантирует корректную работу Java-программ на любой JVM, совместимой со стандартом.

Все реализации JVM обязаны корректно интерпретировать байт-код, читать `.class`-файлы и обеспечивать выполнение Java-программ согласно спецификациям.
##### Основные издания (платформы) Java

В зависимости от области применения, спецификация Java разделяется на несколько крупных платформенных изданий:

| Издание                                             | Назначение                                                                                 | Основной набор API                                                                               |
|-----------------------------------------------------|--------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| **Java SE (Standard Edition)**                      | Базовый набор для создания настольных, консольных, серверных приложений общего назначения. | `java.lang`, `java.util`, `java.io`, `java.net`, `java.sql`, `java.time`, `java.math`, `javax.*` |
| **Java EE (Enterprise Edition)**(сейчас Jakarta EE) | Для создания корпоративных, масштабируемых, распределённых систем.                         | `Servlets`, `JSP`, `EJB`, `JPA`, `JMS`, `JTA`, `CDI`, `WebSocket`                                |
| **Java ME (Micro Edition)**                         | Для устройств с ограниченными ресурсами: телефоны, встраиваемые системы, IoT.              | `javax.microedition.*`, ограниченные версии `java.lang` и `java.util`                            |

##### Немного подробнее:

- **Java SE (Standard Edition)**  
    Основная часть Java — стандартный API для большинства задач. Пример: написание обычных приложений, утилит, кроссплатформенных программ.

- **Java EE (Enterprise Edition / Jakarta EE)**  
    Специализирован для крупных корпоративных приложений, серверов приложений, облачных сервисов, микросервисов.  
    Примерные технологии:    
    - **JPA (Java Persistence API)** — работа с БД;
    - **EJB (Enterprise Java Beans)** — распределённые компоненты;
    - **JMS (Java Messaging Service)** — обмен сообщениями;
    - **Servlets и JSP** — работа с веб-запросами.

- **Java ME (Micro Edition)**  
    Используется для разработки ПО для встраиваемых систем, мобильных телефонов, устройств IoT.  
    Сильно ограничен по сравнению с SE (урезанный набор библиотек из-за ограниченных ресурсов устройств).
##### Итог:
**Спецификация языка Java** — это совокупность стандартов, описывающих язык, виртуальную машину и набор стандартных библиотек.  
**Издания Java (SE, EE, ME)** — это разные подмножества спецификаций и API, ориентированные на разные сферы разработки.

#### 3. Иерархия интерфейсов для работы с коллекциями. Особенности Stream API.

> **Def:** **Collection Framework** — это иерархия интерфейсов и их реализаций в JDK, предоставляющая готовые структуры данных и алгоритмы для хранения и обработки данных.
##### Базовая иерархия Collection Framework

В основе всей коллекционной библиотеки Java лежит интерфейс `java.util.Collection` — универсальный интерфейс, описывающий общее поведение всех коллекций.

> **Def:** Интерфейс `Collection` определяет базовые операции над совокупностями объектов: добавление, удаление, проверка наличия, итерация по элементам и др.

При этом `Collection` наследуется от интерфейса `Iterable` — это позволяет использовать все коллекции Java в `for-each` циклах. Интерфейс `Iterable` определяет метод `iterator()`, который возвращает объект `Iterator` — итератор по коллекции.
##### Иерархия Collection:
![[Pasted image 20250613211004.png]]
##### Основные подинтерфейсы:
- **List** — коллекции, хранящие элементы в определённом порядке, допускают дублирование элементов.
    - Реализации: `ArrayList`, `LinkedList`, `Vector`, `Stack`.
- **Set** — коллекции, хранящие только уникальные элементы (без дубликатов).
    - Реализации: `HashSet`, `LinkedHashSet`, `TreeSet`.
- **Queue** — коллекции, поддерживающие обработку элементов в порядке их добавления (очередь, стек, приоритетная очередь).
    - Реализации: `PriorityQueue`, `ArrayDeque`.
- **Map (не является подтипом Collection)** — хранит пары "ключ-значение".
    - Реализации: `HashMap`, `TreeMap`, `LinkedHashMap`, `ConcurrentHashMap`.
##### AbstractCollection

> **Def:** `AbstractCollection` — это абстрактный класс, реализующий часть логики `Collection` и предоставляющий скелет для создания собственных коллекций.

Реализации `AbstractCollection` используют итератор (`Iterator`) для реализации большинства базовых операций (`contains()`, `toArray()`, `remove()`, и т.д.).
##### Потокобезопасность коллекций:
- **Synchronized Collections (потокобезопасные):**
    - Только один поток может работать с коллекцией одновременно.
    - Используется синхронизация.
    - Могут снижать производительность из-за блокировок.
    - Пример: `Collections.synchronizedList(new ArrayList<>())`.

- **Non-Synchronized Collections (непотокобезопасные):**
    - Несколько потоков могут обращаться к коллекции одновременно.
    - Требуют внешней синхронизации для потокобезопасности.
    - Пример: `ArrayList`, `HashMap`.

- Для современных многопоточных приложений в Java также существуют высокопроизводительные потокобезопасные коллекции из пакета `java.util.concurrent` (например, `ConcurrentHashMap`).
##### Stream API 

> **Def:** **Stream API** — специальный набор классов, позволяющий декларативно обрабатывать коллекции и другие источники данных в функциональном стиле.

> В отличие от коллекций, стримы не хранят данные — они предназначены для обработки и преобразования данных "на лету".

##### Создание стримов:

- Из коллекций:
```java
list.stream()    
```
- Пустой стрим:
```java
Stream.empty()
```
- Из набора значений:
```java
Stream.of("A", "B", "C")
```
##### Операторы Stream API:

- **Промежуточные (intermediate / lazy):**  
    Выполняют преобразования, возвращают новый стрим. Можно вызывать цепочкой.
    - Примеры: `filter()`, `map()`, `sorted()`, `limit()`, `distinct()`.

- **Терминальные (terminal / eager):**  
    Завершают работу стрима, выполняют вычисления.
    - Примеры: `collect()`, `forEach()`, `reduce()`, `count()`, `anyMatch()`, `allMatch()`.
##### Пример использования Stream API:

```java
List<String> names = Arrays.asList("Anna", "Bob", "Alex");
List<String> filteredNames = names.stream()
                                  .filter(s -> s.startsWith("A"))
                                  .collect(Collectors.toList());
```

##### Главное отличие коллекций и стримов:

| Коллекции                              | Стримы                                       |
|----------------------------------------|----------------------------------------------|
| Хранят данные                          | Не хранят данные                             |
| Позволяют доступ к отдельным элементам | Не поддерживают доступ к отдельным элементам |
| Поддерживают модификацию               | Только чтение и преобразование               |
| Работают в памяти                      | Могут работать и с бесконечными источниками  |
| Императивный стиль                     | Декларативный стиль (похож на LINQ в C#)     |

#### 4. Системы сборок, предназначение, ключевые особенности. Понятие модульности и конвенций иерархии пакетов

##### Общая информация
**Из чего состоит программа**
- кодовая база;
- ресурсы, необходимые для работы приложения, (конфигурация, картинки и т.д.);
- библиотеки;
- стороннее ПО, (СУБД, сервера, брокеры сообщений);
- что угодно еще...
##### Системы сборки
> Инструменты для автоматизации процессов компиляции, тестирования, упаковки и развертывания Java-приложений. Они упрощают управление зависимостями, настройку проекта и сборку исполняемых файлов (JAR, WAR и др.).
##### Зачем нужны
- простота подключения зависимостей
- упрощение этапов компиляции, тестирования и упаковки
- поддержка разных сред разработки
##### Maven
##### Что это за чудо
Инструмент/фреймворк/система, помогающая разработчикам и специалистам DevOps собрать проект со всеми необходимыми для его работы библиотеками и запустить его в среде эксплуатации

Maven основывается на *объектной модели проекта* (POM). Кроме файлов, содержащих код, и необходимых библиотеках также в эту модель входят файлы конфигурации, информация о разработчиках, дефектах, организации-разработчике, лицензиях и т.д.

> **Def:** Объектная модель в Java** — это представление данных и логики приложения в виде взаимосвязанных объектов, которые основаны на классах
##### Зависимости в maven

Зависимость в терминологии Maven – это какая-либо библиотека, которая необходима данному проекту для корректной работы. Библиотека представляет из себя обычный Java-проект, который собрали и распространили с помощью Maven

У таких проектов есть три идентификатора:
- **groupId**
- **artifactId**
- **version**
##### Области видимости зависимостей
Каждую зависимость можно подключить к конкретному этапу сборки проекта.

Например, можно подключить зависимость так, чтобы она существовала в проекте только на фазе тестирования. То есть, данная библиотека будет находится в составе проекта только на этапе тестирования, а после того, как цикл прошел фазу тестирования будет исключена из проекта.

В Maven есть 6 областей видимости:
- **compile** - область видимости по умолчанию
- **provided** - аналогично типу compile, но во время выполнения зависимость подставляет JDK
- **runtime** - указывает, что зависимость не требуется во время компиляции, и будет подставлена именно во время выполнения
- **test** - указывает, что зависимость требуется только во время компиляции и выполнения
- **system** - устарела
- **import** - подставляет зависимости, указанные в отдельном блоке dependencyManagement в POM
##### Пример
Самый известный для вас на данный момент пример – это
  **org.junit.jupiter:junit-jupiter-api:5.9.2**
где:
- *org.junit.jupiter* - groupId
- *junit-jupiter-api* - artifactId
- *5.9.2* - version
##### Жизненный цикл
##### Концепция
Maven основан на концепции жизненного цикла сборки. Пользователю нужно указать одну из фаз жизненного цикла, а Maven на основе конфигурации POM сам сделает все, что нужно пользователю.

Фазы Maven представляют из себя следующие команды:
- **clean**,
- **validate**,
- **compile**,
- **test**,
- **package**,
- **verify**,
- **install**,
- **site**,
- **deploy**

Которые объединяются в три жизненных цикла Maven:
- ***clean***, 
- ***default***,
- ***site***.
##### Жизненный цикл очистки
1. **pre-clean** – выполнить процессы, необходимые до очистки проекта
2. **clean** – удалить все файлы, предыдущей сборки
3. **post-clean** – выполнить процессы, необходимые для завершения очистки проекта
##### Жизненный цикл генерации сайта проекта
1. **pre-site** – выполнить процессы, необходимые до создания сайта проекта
2. **site** – генерировать сайт проекта
3. **post-site** – выполнить процессы, необходимые для завершения создания сайта и подготовки к развертыванию сайта
4. **site-deploy** – развернуть сайт на указанный веб-сервер
##### Жизненный цикл по умолчанию
1. **validate** – проверить доступность всей необходимой информации для сборки проекта
2. **compile** – скомпилировать исходный код
3. **test-compile** – скомпилировать исходный код тестов
4. **test** – запустить unit-тесты
5. **package** – упаковать скомпилированный исходный код в необходимый формат (war, jar и т.д.)
6. **integration-test** – развернуть пакет для запуска интеграционных тестов
7. **verify** – проверить собранный пакет на работоспособность
8. **install** – установить проект в локальный репозиторий
9. **deploy** – копировать полностью проверенный пакет в удаленный репозиторий (откуда потом может быть доставлен до web-сервера и развернут там)
##### Цели Maven
На самом деле, когда мы даем команду на выполнение какой-то фазы, выполняется не сама фаза, а конкретные цели, которые в ней заложены. То есть, исполняемыми *«методами являются именно цели»*. Сами фазы – это обертка, для выполнения команд используются цели.

> Например, есть фаза Maven site, мы можем ее вызвать командой mvn site, но на самом деле выполняется цель этой фазы, которая выглядит так mvn site:site

##### Плагины Maven

> **Def:** Плагины Maven – это вторая после зависимостей сущность данного инструмента. Если зависимость выступает статической библиотекой, которая просто присутствует или отсутствует в проекте, то плагин – это, грубо говоря, метод, который совершает какие-то действия.

На самом деле, фазы – это и есть плагины, просто вшитые в Maven по умолчанию. Также есть еще множество различных плагинов для различных целей. А еще вы можете написать собственный плагин, нужный именно вам.

А, если быть совсем точными, то плагины – это группа целей, так как мы уже знаем, что именно за выполнение команд отвечают цели.
##### Пример
Рассмотрим подробно один из плагинов:
   **org.apache.maven.plugins:maven-jar-plugin:2.6**
тут:
 - **org.apache.maven.plugins** - groupId
 - **maven-jar-plugin** - artifactId
 - **2.6** - version

Данный плагин отвечает за генерацию документации в формате JavaDoc из исходного кода вашего проекта

> **Def:** POM – это одновременно и объектная модель объекта, и файл pom.xml, в котором хранится метаинформация о проекте, информация о зависимостях и описаны необходимые плагины.
##### Gradle
##### Что за чудо
Инструмент автоматизации сборки с открытым исходным кодом.
- помогает автоматизировать широкий спектр сценариев сборки ПО, используя встроенные функции, сторонние плагины или пользовательскую логику сборки
- предоставляет высокоуровневый, декларативный и выразительный язык сборки, который упрощает чтение и написание логики сборки
- обеспечивает надежные результаты, используя такие оптимизации, как инкрементальные сборки, кэширование сборок и параллельное выполнение
- поддерживает Android, Java, Kotlin Multiplatform, Groovy, Scala, JavaScript и C/C++
##### Области видимости
- **implementation** – зависимости, необходимые, как для компиляции, так и для выполнения
- **api** – открытый “implementation”
- **compileOnly** – зависимости, необходимые только для компиляции
- **compileOnlyApi** – открытый “compileOnly”
- **runtimeOnly** – зависимости, необходимые только для выполнения
- **testImplementation** – зависимости, необходимые для компиляции и выполнения тестов
- **testCompileOnly** – зависимости, необходимые только для компиляции тестов
- **testRuntimeOnly** – зависимости, необходимые только для выполнения тестов
##### Визуализация областей видимости

| Конфигурация       | Компиляция | Рантайм  | Тесты | Транзитивность |
|--------------------|------------|----------|-------|----------------|
| implementation     | ✓          | ✓        | ✗     | ✗              |
| api                | ✓          | ✓        | ✗     | ✓              |
| compileOnly        | ✓          | ✗        | ✗     | ✗              |
| runtimeOnly        | ✗          | ✓        | ✗     | ✓              |
| testImplementation | ✗          | ✗        | ✓     | ✗              |
| testCompileOnly    | ✗ (test)   | ✗        | ✓     | ✗              |
| testRuntimeOnly    | ✗          | ✗ (test) | ✓     | ✓              |
##### Репозитории
Gradle не имеет собственных репозиториев и в качестве источника зависимостей использует Maven и Ivy репозитории. При этом интерфейс для работы с репозиториями не отличается на базовом уровне.
##### Wrapper
> **Def:** Это скрипт, который запускает задачи Gradle с объявленной версией. Если объявленная версия не установлена, Wrapper устанавливает требуемую.
##### Преимущества:
- создание проектов с помощью Wrapper локально позволяет вам предварительно не устанавливать Gradle
- у каждого участника команды и на конвейерах CI проект собирается под одной и той же версией Gradle
- легкое обновление до новой версии Gradle путем изменения настроек Wrapper
##### Сравнение Maven и Gradle
**Maven**
- проще в освоении
- набор поведений и настроек по умолчанию
 **Gradle**
- производительность (инкрементальные сборки, кэш)
- гибкость
- более глубокое управление зависимостями
- поддержка нескольких языков программирования
- доменно-специфический язык программирования: DSL

#### 5. Автоматическое управление памятью. Алгоритмы очистки.

> **Def:** **Автоматическое управление памятью** — механизм, при котором среда исполнения сама контролирует выделение и освобождение памяти, избавляя программиста от необходимости вручную удалять объекты, которые больше не нужны.

> **Def:** **Garbage Collector (GC)** — компонент JVM, который автоматически освобождает память, занятую неиспользуемыми объектами.
##### Основная задача GC:
1. **Обнаружить мусор** — определить объекты, к которым больше нет доступа.
2. **Очистить память** — освободить ресурсы, занятые этими объектами.
##### Что такое мусор?

> **Def:** **Мусор (garbage)** — объект в памяти, к которому невозможно получить доступ из исполняемого кода, т.е. на него не осталось активных ссылок.
##### Почему сборка мусора важна?
- Избавляет разработчика от ручного управления памятью.
- Предотвращает утечки памяти.
- Предотвращает ошибки двойного освобождения памяти.
- Повышает стабильность и безопасность приложений.
##### Методы определения мусора

1. **Reference Counting (подсчет ссылок)**
> Каждому объекту сопоставляется счетчик ссылок. Когда счетчик становится равным нулю — объект можно удалить.
	**Минусы:** циклические ссылки могут привести к утечкам памяти.

2. **Tracing (трассировка ссылок)**
> Вводится понятие **GC Root** — это корневые объекты, от которых начинается обход всех достижимых объектов. Всё, что недостижимо — мусор.

> **Def:** **GC Root** — объект, который всегда считается живым и от которого ведётся поиск достижимых объектов.

Примеры GC Root в Java:
- Локальные переменные и параметры методов (в том числе в `main()`).
- Активные потоки.
- Статические поля.
- JNI ссылки.
##### Алгоритмы очистки памяти

В Java реализовано несколько базовых алгоритмов работы GC:

> **Def:** **Копирующая сборка с поколениями (Copying GC, Generational GC)**
- Разделяет память на две области: «from» и «to».
- Живые объекты копируются в пустую область, остальная память освобождается сразу.
- Эффективен для короткоживущих объектов.

> **Def:** **Отслеживание и очистка (Mark & Sweep)**
- Сначала объекты помечаются как «живые» или «мертвые» при трассировке.
- Потом освобождается память от всех неиспользуемых объектов.
- После нескольких проходов может привести к фрагментации памяти.

> **Def:** **Отслеживание, очистка и дефрагментация (Mark & Compact)**
- После пометки «живых» объектов память уплотняется, объекты сдвигаются, фрагментация устраняется.
- Медленнее, но позволяет поддерживать более компактное расположение данных в памяти.

##### Особенности управления памятью в JVM

> **Def:** **Heap (куча)** — область памяти для хранения всех объектов.  
> **Def:** **Stack (стек)** — область памяти, где хранятся ссылки на объекты и примитивные типы, локальные переменные, параметры методов.

- Стек — создается отдельно для каждого потока.
- Куча — общая для всех потоков.
##### Итог:
- JVM полностью управляет памятью за нас.
- Благодаря GC снижается количество ошибок.
- Реализовано несколько алгоритмов поиска и удаления мусора.
- Разработчик может только косвенно влиять на поведение GC — например, через настройки JVM.
#### 6. Сборка мусора на поколениях. Устройство кучи. Принцип работы.

##### Основная идея поколенческой сборки мусора

Поколенческая сборка мусора основана на **«слабой гипотезе о поколениях»**, которая сформулирована на основе практических наблюдений за жизненным циклом объектов в программах:

1. **Большинство объектов живет либо очень недолго, либо очень долго.**
- 90% объектов умирают сразу после создания.
- Очень небольшое количество объектов живет долго.

2. **Между старыми и новыми объектами существует мало ссылок.**
- Поэтому сборка мусора может рассматривать их раздельно.

Эта гипотеза позволяет оптимизировать работу сборщика мусора, разделив память по возрасту объектов и применяя к каждому поколению свой, наиболее эффективный алгоритм.
##### Устройство памяти в Java

**Stack memory (Стековая память)**
- Хранит:
    - ссылки на объекты в куче;
    - значения примитивных типов.
- Работает по принципу **LIFO** (Last-In-First-Out).
- Выделяется для каждого потока отдельно.
- Очищается автоматически при выходе из метода.
- Переменные в стеке имеют ограниченную область видимости

**Heap memory (Куча)
- Хранит все объекты, созданные во время выполнения программы (`new`).
- Общая для всех потоков.
- Управляется сборщиком мусора (GC).
- Делится на поколения:

| Поколение             | Назначение                          |
|-----------------------|-------------------------------------|
| Young Generation      | Для новых объектов                  |
| Old Generation        | Для долгоживущих объектов           |
| (Metaspace в Java 8+) | Для хранения метаинформации классов |

##### Особые пулы

**String Pool**
- Отдельная область в heap.
- Хранит строковые литералы.
- Повторяющееся значение хранится в одном экземпляре:

```java
String s1 = "hello";  // создаст строку "hello"
String s2 = "hello";  // s2 будет ссылаться на тот же объект
```

- Но `new String("hello")` создаст новый объект в куче.

**Числовые пулы (Integer, Byte, Short, Long, Character)
- Кэшируются значения в диапазоне `-128..127`.
- Пример:

```java
Integer a = 100;  // из пула
Integer b = 100;  // из пула
Integer c = 200;  // создается новый объект
```

- Настроить размер можно для `Long` с помощью параметра JVM:  
    `-XX:AutoBoxCacheMax=n`.

##### Структура кучи (Generational Heap)

**Young Generation (Молодое поколение)**
- Делится на:
    - **Eden Space** — область, куда создаются новые объекты.
    - **Survivor Space S0 и S1** — области для "выживших" объектов.

- Принцип работы:   
    1. Все новые объекты создаются в **Eden**.
    2. При переполнении **Eden** запускается **Minor GC**.
    3. Живые объекты из Eden перемещаются в **Survivor Space S0**.
    4. При следующей Minor GC выжившие из Eden и S0 перемещаются в S1.
    5. S0 и S1 при каждой сборке меняются ролями.
    6. После нескольких Minor GC (обычно 15 раз, параметр `MaxTenuringThreshold`) объекты перемещаются в **Old Generation**.

**Old Generation (Старое поколение / Tenured)**
- Содержит долгоживущие объекты.
- Когда в Old Generation заканчивается память — запускается **Major GC**.
- Major GC обычно работает дольше, чем Minor GC.
##### Full GC
- Очищает как Young, так и Old Generation.
- Очень дорогая операция — стараются избегать.
##### Алгоритмы сборки мусора по поколениям

| Тип сборки                | Где работает                                      | Когда вызывается                                                                  | Особенности работы                                                                                                                                                                                                                                                |
|---------------------------|---------------------------------------------------|-----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Minor GC**              | Только в Young Generation (Eden + Survivor S0/S1) | Когда Eden заполняется новыми объектами                                           | - Быстрая сборка. <br>- Останавливает выполнение потоков (**Stop-The-World pause**), но пауза очень короткая. - Обычно не требует перемещения объектов в Old Generation (если они "молодые"). <br>- Частая сборка: может происходить десятки раз в секунду.       |
| **Major GC (или Old GC)** | Только в Old Generation                           | Когда Old Generation заполняется                                                  | - Более долгая **Stop-The-World pause**. <br>- Проверяет живость долгоживущих объектов. <br>- Может делать дефрагментацию памяти (сдвиг объектов для устранения фрагментации). <br>- Зависит от используемого алгоритма (CMS, G1 и др).                           |
| **Full GC**               | Вся куча (Young + Old + Metaspace)                | Когда не хватает памяти в обеих областях<br>Либо вызывается вручную `System.gc()` | - Самая "дорогая" сборка. <br>- Останавливает все потоки (длинный Stop-The-World)<br>- Полностью очищает все поколения, освобождает неиспользуемую память <br>- Обычно стараются избегать частых Full GC — признак неправильной настройки heap или утечек памяти. |

##### Принцип работы (подробный сценарий)

1. Программа создает объект → он помещается в **Eden**.  
2. Когда **Eden** заполняется → запускается **Minor GC**:
- Все объекты без ссылок удаляются.
- Живые объекты перемещаются в **S0**.
3. На следующей сборке:
- Живые объекты из Eden и S0 перемещаются в **S1**.
- S0 и S1 меняются местами.
4. После нескольких Minor GC:
- Объекты, которые "пережили" порог (напр. 15 раз), перемещаются в **Old Generation**.
5. Если Old Generation переполнен → запускается **Major GC**.
6. Если требуется → JVM может инициировать **Full GC**.

##### Преимущества поколенческой сборки
- Ускоряет сборку мусора за счёт:
    - Быстрого удаления молодых объектов.
    - Редкой и более эффективной обработки старых объектов.
- Эффективно работает в реальных приложениях, где большинство объектов "живут недолго".
##### Итоговая схема поколенческой GC:

```txt
[ Eden ] --> [ Survivor S0 ] <--> [ Survivor S1 ] --> [ Old Generation ]
```

#### 7. Технологии Java EE для работы с данными. Популярные имплементации спецификации JPA.

#### 8. Особенности реализации CDI в Spring. Внедрение зависимостей. Инверсия контроля.

> **Def:** **Spring Framework** — фреймворк с открытым исходным кодом для языков JVM (Java, Kotlin, Groovy, Scala) и форк для C#, являющийся расширением и альтернативой Java EE (Jakarta EE).

- Совместим с Java EE (но не наоборот).
- Содержит множество расширений (MVC, Data и др.).
- Активно поддерживается сообществом.

> **Def:** **Inversion of Control (IoC) контейнер** — центральный компонент Spring, управляющий жизненным циклом объектов (bean’ов): создание, настройка, связывание и инициализация с помощью рефлексии.

В **Spring** контейнером для **IoC** выступает интерфейс **ApplicationContext**. Он отвечает за создание, настройку и сборку объектов, которые в **Spring** называются **Bean** – компонентами. Также **Context** отвечает за управление жизненными циклами бинов.

> **Def: Spring Bean** – это обычный объект _Java_, (_POJO_), в который закладывается дополнительная метаинформация, с помощью которой **ApplicationContext** распознает в нем сущность, которой он должен управлять.

##### Реализация инверсии управления

Есть два основных способа реализации IoC:

- **Поиск зависимостей (Dependency Lookup)** — вызывающий объект запрашивает у контейнера экземпляр объекта по имени или типу.
- **Внедрение зависимостей (Dependency Injection)** — контейнер передаёт объект другому объекту (через конструктор, сеттер или свойства).
##### Способы внедрения зависимостей:
- Внедрение через конструктор
- Внедрение через set-метод
- Внедрение через свойства (прямое присваивание)
##### Конфигурация Spring и создание BeanDefinition

> **Def:** **BeanDefinition** — объект, содержащий метаданные для создания bean’а (класс, scope, методы инициализации и т.д.).

##### Способы конфигурации:
1. **XML-конфигурация**
- Контекст создаётся через `ClassPathXmlApplicationContext("context.xml")`.
- Используется класс `XmlBeanDefinitionReader` (реализует интерфейс `BeanDefinitionReader`).
- Каждая запись из XML превращается в `BeanDefinition`, которые хранятся в `DefaultListableBeanFactory`.

1. **Аннотации**
- Контекст создаётся через `AnnotationConfigApplicationContext`, куда передаётся пакет для сканирования или класс, помеченный `@Configuration`.
- Основные компоненты:
    - `ClassPathBeanDefinitionScanner` — сканирует указанный пакет на классы с аннотациями `@Component` и создает для них `BeanDefinition`.
    - `AnnotatedBeanDefinitionReader` — регистрирует `@Configuration` и специальный `BeanFactoryPostProcessor` (`BeanDefinitionRegistryPostProcessor`), который с помощью `ConfigurationClassParser` парсит конфигурационные классы и создаёт `BeanDefinition`.

##### BeanFactoryPostProcessor

> **Def:** **BeanFactoryPostProcessor** — интерфейс, который позволяет изменять `BeanDefinition` до создания bean’ов.

- Основной метод:  
    `postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)`    
- Через фабрику можно получить список всех `BeanDefinition` и изменить их метаданные.

##### FactoryBean

> **Def:** **FactoryBean** — generic интерфейс, позволяющий делегировать создание bean’ов. Позволяет контролировать процесс создания объектов (использовался особенно в XML-конфигурации).

##### BeanPostProcessor

> **Def:** **BeanPostProcessor** — интерфейс, позволяющий вмешиваться в процесс настройки bean’ов после их создания и до попадания в контейнер.

- Содержит два метода:    
    - `postProcessBeforeInitialization` — вызывается перед методом инициализации bean’а.
    - `postProcessAfterInitialization` — вызывается после метода инициализации.

- Оба метода вызываются для каждого bean’а.
- Используется, например, для создания прокси-объектов (обычно в `postProcessAfterInitialization`).

Разница между методами в порядке их вызова, первый вызывается до инициализации бина, второй после.

- Оба метода обязаны вернуть в ответ бин, потому что через BeanPostProcessor проходят абсолютно все бины, даже если с ними ничего не произойдет внутри, вы все равно получите на выходе все бины, в которых по ссылкам лежит null – значения.
- BeanPostProcessor прекрасно подходит для реализации прокси, (имейте в виду, что прокси принято делать в методе postProcessAfterInitialization, то есть после инициализации бина).
##### Области видимости (Scope) bean’ов

- **SCOPE_SINGLETON** — bean создаётся один раз при инициализации контекста.
- **SCOPE_PROTOTYPE** — bean создаётся заново при каждом запросе.
##### Spring Been Scopes

- **Singleton** – область видимости по умолчанию, один бин на весь runtime.
- **Prototype** – возвращает новый экземпляр каждый раз, когда запрашивается из ApplicationContext.
- **Request** – на каждый HTTP – запрос создается новый экземпляр.
- **Session** – на каждую HTTP – сессию создается новый экземпляр.
- **Application** – один на ServletContext.
- **Websocket** – один на каждый WebSocket.
#### 9. Что такое «сервлет»? Отличия сервера приложений и контейнеров сервлетов.

Любой веб-фреймворк работает не сам по себе. Для запуска написанного на нем приложения нужен веб-сервер. Такой веб-сервер загружает приложение внутрь себя и запускает. Из этого следует два вывода:

- Такой веб-сервер должен быть написан на том же языке — например, в Java среди основных веб-серверов выделяют Tomcat и Jetty
- Веб-сервер и фреймворк должны знать друг о друге, чтобы они могли работать совместно

Теперь представьте, что у нас есть десятки фреймворков и десятки веб-серверов. Как им всем знать друг о друге? В худшем случае нам пришлось бы писать код для совместимости каждого с каждым. Это было бы пустой тратой ресурсов команд разработчиков, а создание нового фреймворка было бы очень затруднено.

> **Def:** **Сервлет** — Java-класс, расширяющий функциональность сервера, который обрабатывает клиентские HTTP-запросы и возвращает ответы. Работает в среде веб-сервера через контейнер сервлетов.

##### Зачем нужен сервлет?
- Веб-фреймворки (Spring, Javalin и др.) внутри превращают свои обработки в сервлеты.
- Веб-сервер должен поддерживать сервлеты, чтобы запускать Java веб-приложения.
- Обеспечивает стандартный механизм взаимодействия между сервером и приложением.
##### Жизненный цикл сервлета
1. **Инициализация (`init()`)** — вызывается один раз при загрузке сервлета.
2. **Обработка запросов (`service()`)** — вызывается на каждый запрос, делегирует вызовы методам `doGet()`, `doPost()` и т.д
3. **Завершение (`destroy()`)** — вызывается при выгрузке сервлета.
##### Виды сервлетов
- **HttpServlet** — для обработки HTTP-запросов (GET, POST, PUT, DELETE и др.)
- **GenericServlet** — базовый класс для не-HTTP сервлетов

> **Def: Контейнер сервлетов (Servlet Container)** - минимальная среда для запуска веб-приложений, которая управляет жизненным циклом сервлетов, обработкой HTTP-запросов и сессиями.

- Запускает сервлеты и JSP
- Управляет сессиями (HTTP Session)
- Примеры: Tomcat, Jetty, Undertow
- Используется для REST API, простых веб-приложений и микросервисов


> **Def: Сервер приложений (Application Server)** - полноценная среда для запуска корпоративных приложений с поддержкой всей спецификации Java EE/Jakarta EE.

- Включает контейнер сервлетов и дополнительно:
    - EJB (Enterprise Java Beans)
    - JMS (Java Message Service)
    - JTA (Java Transaction API)
    - JPA (Java Persistence API)
    - JCA (Java Connector Architecture)
    - Безопасность (JAAS, JASPIC)
- Примеры: WildFly, GlassFish, WebLogic, WebSphere
- Используется для крупных enterprise-приложений с распределёнными транзакциями

##### Сравнение контейнера сервлетов и сервера приложений

| -                       | Контейнер сервлетов        | Сервер приложений             |
|-------------------------|----------------------------|-------------------------------|
| Поддержка сервлетов/JSP | Да                         | Да                            |
| EJB                     | Нет                        | Да                            |
| JMS                     | Нет                        | Да                            |
| JTA                     | Ограниченная               | Полная                        |
| JPA                     | Через сторонние библиотеки | Встроенная поддержка          |
| JCA                     | Нет                        | Да                            |
| Безопасность            | Базовая (HTTP + SSL)       | Расширенная (JAAS, JASPIC)    |
| Примеры                 | Tomcat, Jetty              | WildFly, GlassFish, WebLogic  |
| Использование           | Веб-приложения, REST API   | Крупные корпоративные системы |

#### 10. Жизненный цикл запроса в рамках DispatcherServlet в Spring.

> **Def:** **DispatcherServlet** — главный фронт-контроллер в Spring MVC, который принимает HTTP-запросы, определяет подходящий обработчик и управляет полным циклом обработки запроса в приложении.
##### Контекст: Контейнер сервлетов и сервер приложений
**Контейнер сервлетов (Servlet Container):**
- Минимальная среда для запуска веб-приложений, обрабатывающая сервлеты, JSP, веб-компоненты.
- Функции: запуск сервлетов/JSP, обработка HTTP-запросов/ответов, управление жизненным циклом и сессиями.
- Примеры: Tomcat, Jetty, Undertow.
- Использование: REST API, простые MVC-приложения, микросервисы.

**Сервер приложений (Application Server):**

- Полноценная среда для корпоративных приложений с поддержкой всех спецификаций Java EE/Jakarta EE.
- Дополнительно поддерживает EJB, JMS, JTA, JPA, JCA, безопасность.
- Примеры: WildFly, GlassFish, WebLogic, WebSphere.
- Использование: крупные enterprise-системы с распределёнными транзакциями.

##### Жизненный цикл запроса в DispatcherServlet

1. **Получение запроса**
    - Запрос (`HttpServletRequest`) поступает в контейнер сервлетов (например, Tomcat).
    - Контейнер передаёт запрос в **DispatcherServlet**.

2. **Определение обработчика (HandlerMapping)**    
    - DispatcherServlet обращается к зарегистрированным `HandlerMapping` (например, `RequestMappingHandlerMapping`).
    - Определяет контроллер/метод по URL, HTTP-методу, заголовкам и параметрам.

3. **Выполнение цепочки интерцепторов (HandlerInterceptor)**    
    - Вызываются `preHandle` интерцепторы.
    - Если какой-то возвращает `false`, обработка прекращается.

4. **Вызов обработчика (HandlerAdapter)**
    - DispatcherServlet вызывает контроллер через `HandlerAdapter` (например, `RequestMappingHandlerAdapter`).
    - Параметры метода резолвятся с помощью `ArgumentResolver` (@RequestParam, @RequestBody и др.).
    - Контроллер возвращает результат (имя view, DTO, `ResponseEntity` и др.).

5. **Обработка результата (HandlerReturnValueHandler)**    
    - Результат передается `ViewResolver` (для имени view) или `HttpMessageConverter` (для тела ответа, например, JSON).
    - Если возвращён `String` — ищется шаблон (Thymeleaf, JSP и др.).
    - Если возвращен `@ResponseBody` — результат сериализуется.

6. **Пост-обработка интерцепторами (postHandle)**    
    - Вызываются `postHandle` интерцепторы.
    - Выполняются после контроллера, но до рендеринга ответа.

7. **Рендеринг ответа**    
    - Через `ViewResolver` (генерация HTML, JSP и др.) или
    - Через `HttpMessageConverter` (форматирование тела ответа).

8. **Завершение обработки (afterCompletion)**
    - Вызываются `afterCompletion` интерцепторы.
    - Выполняются даже при исключениях, для очистки ресурсов.

9. **Отправка ответа клиенту**    
    - DispatcherServlet завершает цикл и отправляет ответ через `HttpServletResponse`.

10. **Обработка исключений**    
    - При возникновении исключений делегирует их обработку `HandlerExceptionResolver`.
    - Можно настроить глобальные обработчики через `@ControllerAdvice`.
#### 11. Основные задачи решаемые с помощью Spring Boot. С помощью каких инструментов достигается результат?

> **Def:** Spring Boot — дополнение к Spring Framework, которое упрощает и ускоряет разработку приложений за счёт автоматизации конфигураций и снижения количества рутинных настроек.
##### Зачем нужен Spring Boot?
Spring сам по себе содержит множество зависимостей и сложных конфигураций, часто описанных в XML. Это создаёт трудности при изучении и начальной настройке проекта. Spring Boot решает эти проблемы, предлагая:
- Быстрый старт и минимальную конфигурацию.
- Умные дефолты и автоматическую настройку компонентов.
- Упрощение управления зависимостями и совместимостью версий.
- Отказ от XML-конфигураций в пользу аннотаций и properties-файлов.
- Встроенный сервер приложений для запуска web-приложений.
##### Проблемы без Spring Boot

При создании Spring-приложения вручную разработчику нужно:

- Самостоятельно подбирать и подключать нужные модули Spring (MVC, JDBC, ORM и др.).
- Искать и согласовывать версии сторонних библиотек (например, Hibernate, Jackson).
- Конфигурировать источники данных, транзакции и прочие компоненты DAO.
- Создавать класс с основной конфигурацией приложения.
##### Основные цели Spring Boot
- Обеспечить быстрый старт разработки приложений на Spring.
- Позволить настраивать и переопределять стандартное поведение.
- Встроить нефункциональные возможности (веб-сервер, безопасность, метрики, тестирование, проверка работоспособности).
- Упростить поддержку и масштабирование проектов.

##### Как Spring Boot достигает результата?

- Использует **starter зависимости** — наборы преднастроенных библиотек для типовых задач.
- Автоматически конфигурирует компоненты на основе зависимостей (**AutoConfiguration**).
- Включает встроенный сервер приложений (обычно Apache Tomcat).
- Предоставляет готовые шаблоны и решения для распространённых сценариев (метрики, внешняя конфигурация и др.).

##### Starter-пакеты
- Это дескрипторы зависимостей, которые автоматически подтягивают нужные библиотеки и конфигурации.
- Пример: `spring-boot-starter-data-jpa` подключает Spring Data JPA, драйверы БД, Hibernate и др.
- `spring-boot-starter-web` — для создания web-приложений с Spring MVC, Jackson, Tomcat.
- Позволяют избежать ручного поиска совместимых версий и сложной настройки.

##### Встроенный Application Server

- Обычно используется **Apache Tomcat** — контейнер сервлетов для выполнения Java web-приложений.
- DispatcherServlet Spring работает внутри этого контейнера, обеспечивая маршрутизацию и обработку HTTP-запросов.

##### AutoConfiguration
- Ключевая возможность Spring Boot — автоматическая настройка приложения.
- При старте фреймворк анализирует добавленные jar-зависимости и на их основе создаёт и конфигурирует необходимые Spring-бины.

##### Spring Initializer
- Онлайн-сервис для генерации стартового Spring Boot проекта с нужными зависимостями.
- Позволяет быстро получить готовую заготовку с настроенными скриптами сборки (Maven или Gradle).
- Интегрирован в популярные IDE (например, IntelliJ IDEA).

##### Spring Beans и внедрение зависимостей
- Аннотация `@SpringBootApplication` включает `@ComponentScan`, автоматически регистрируя компоненты (`@Component`, `@Service`, `@Repository`, `@Controller`) как Spring-бины.
- Облегчает организацию и управление зависимостями внутри приложения.

##### DevTools (инструменты для разработки)
- Позволяют автоматический перезапуск приложения при изменениях в исходниках (`spring-boot-devtools`).
- Поддерживают **hot reload**, ускоряя цикл разработки.
- Отключаются в production-сборках для безопасности.
- Используют два загрузчика классов: один для неизменяемых библиотек, другой — для классов в разработке, что ускоряет перезапуск.
##### Цикл жизни Spring Application

Spring Boot генерирует и обрабатывает ряд событий в процессе запуска:
- `ApplicationStartingEvent` — начало запуска приложения.
- `ApplicationEnvironmentPreparedEvent` — окружение известно, но контекст еще не создан.
- `ApplicationContextInitializedEvent` — контекст подготовлен, но бины не загружены.
- `ApplicationPreparedEvent` — перед обновлением контекста.
- `ApplicationStartedEvent` — контекст обновлен, но приложение ещё не готово.
- `AvailabilityChangeEvent` с `LivenessState.CORRECT` — приложение считается живым.
- `ApplicationReadyEvent` — приложение готово к работе.
- `AvailabilityChangeEvent` с `ReadinessState.ACCEPTING_TRAFFIC` — приложение принимает запросы.
- `ApplicationFailedEvent` — возникло исключение при запуске.

Эти события позволяют внедрять дополнительные слушатели для управления процессом запуска и интеграции.
Таким образом, Spring Boot значительно упрощает разработку, снижает порог входа и автоматизирует множество задач, необходимых для создания современного Spring-приложения.

#### 12. Инструменты и типовые решения для аутентификации и авторизации запросов.
##### Spring Security

> **Def:** Spring Security — это Java/JavaEE фреймворк для реализации аутентификации, авторизации и других аспектов безопасности в корпоративных приложениях на Spring Framework.
##### Что это?
Spring Security предоставляет комплексные средства для защиты приложений: аутентификацию пользователей, управление правами доступа (авторизацию), защиту от CSRF, обработку сессий, а также интеграцию с различными протоколами и механизмами безопасности.
##### Как работает?
Spring Security основан на паттерне «Цепочка обязанностей» (Chain of Responsibility). Каждый HTTP-запрос проходит через последовательность фильтров, которые последовательно проверяют и обрабатывают запрос для обеспечения безопасности.
##### Основные фильтры Spring Security
- **WebAsyncManagerIntegrationFilter**  
    Интегрирует SecurityContext с WebAsyncManager, управляющим асинхронными запросами.

- **SecurityContextPersistenceFilter**  
    Загружает SecurityContext из сессии и помещает его в SecurityContextHolder. По умолчанию используется ThreadLocal для хранения контекста безопасности.

- **HeaderWriterFilter**  
    Добавляет необходимые заголовки безопасности в HTTP-ответ.

- **LogoutFilter**  
    Обрабатывает запросы на logout (обычно POST по URL `/logout`), удаляет CSRF-токен, завершает сессию и очищает SecurityContextHolder.

- **BasicAuthenticationFilter**  
    Проверяет наличие заголовка Authorization с Basic-авторизацией, извлекает логин и пароль, передаёт их в AuthenticationManager.

- **RequestCacheAwareFilter**  
    Сохраняет исходный защищённый запрос, чтобы после успешной аутентификации пользователя перенаправить на изначально запрошенный URL.

- **AnonymousAuthenticationFilter**  
    Если пользователь не аутентифицирован, заполняет SecurityContextHolder объектом анонимной аутентификации с ролью `ROLE_ANONYMOUS`. Это предотвращает ошибки NullPointerException и позволяет гибко настраивать доступ для неавторизованных.

- **SessionManagementFilter**  
    Управляет сессией: защита от session fixation (смена ID сессии после логина), ограничение количества сессий, сохранение SecurityContext в сессии через SecurityContextRepository.

- **ExceptionTranslationFilter**  
    Обрабатывает ошибки аутентификации и авторизации, перенаправляет на страницу логина или выдаёт ошибки.

- **FilterSecurityInterceptor**  
    Осуществляет авторизацию на основе URL запроса. Наследуется от AbstractSecurityInterceptor. Вызывает AccessDecisionManager, который принимает решение о доступе пользователя (по умолчанию стратегия AffirmativeBased).

##### AuthenticationManager и AuthenticationProvider
- **AuthenticationManager** — интерфейс, принимающий объект Authentication и возвращающий результат аутентификации (или выбрасывающий исключение при неудаче).
- **AuthenticationProvider** — реализует конкретный способ аутентификации. ProviderManager перебирает доступные AuthenticationProvider и делегирует им проверку.  
    Если провайдер поддерживает тип Authentication, он пытается аутентифицировать и либо возвращает успешный результат, либо бросает исключение. Если ни один провайдер не прошёл, AuthenticationManager выбрасывает исключение.
    
##### Итог

Spring Security — это гибкий и расширяемый фреймворк, обеспечивающий надёжную защиту приложений на Spring, реализующий сложную цепочку фильтров для аутентификации и авторизации, а также предоставляющий удобные механизмы для работы с сессиями, пользователями и правами доступа.
#### 13. Парадигма аспектно-ориентированного программирования. Отличия от ООП.

> **Def:** Аспектно-ориентированное программирование (АОП) — парадигма, развивающая процедурное и объектно-ориентированное программирование, основная идея которой — выделение сквозной функциональности, затрагивающей несколько компонентов.

##### Основные понятия АОП

- **Join point** — точка в программе (например, вызов метода), в которую можно «внедрить» дополнительный код.
- **Pointcut** — набор правил, описывающих выборку join point-ов (например, все методы с определённой аннотацией или названием). Pointcut может включать один или несколько join point-ов, объединённых логическими операциями (&&, ||, !).
- **Advice** — код, который выполняется в точках, определённых pointcut-ом. Виды Advice:
    - Before — до вызова метода
    - After — после вызова метода
    - After returning — после успешного возврата результата
    - After throwing — при возникновении исключения
    - After finally — после блока finally
    - Around — оборачивает вызов метода, позволяет выполнить код до, после или заменить вызов

- **Aspect** — модуль, объединяющий pointcut-ы и соответствующие им advice.
- **Proxy** — динамический прокси-объект, который внедряет логику аспектов:
    - JDK dynamic proxy — используется, если объект реализует интерфейсы
    - CGLIB proxy — применяется, если интерфейсов нет (проксирует классы)
##### Отличия АОП от ООП

| Категория               | АОП                                                            | ООП                                            |
|-------------------------|----------------------------------------------------------------|------------------------------------------------|
| Основная единица        | Аспект (Aspect)                                                | Класс (Class)                                  |
| Основная цель           | Разделение сквозных функциональностей (cross-cutting concerns) | Моделирование предметной области через объекты |
| Принцип работы          | Внедрение кода в join points                                   | Инкапсуляция данных и поведения                |
| Связность               | Низкая (аспекты выделяют общие задачи)                         | Высокая (логика внутри классов)                |
| Повторное использование | Через аспекты, применяемые к разным классам                    | Наследование и композиция                      |
| Примеры применения      | Логирование, транзакции, безопасность, кэширование             | Классы `User`, `Order`, бизнес-логика          |

##### Преимущества АОП
- Уменьшение дублирования кода, связанного с техническими задачами (логирование, безопасность)
- Чистота бизнес-логики — классы не загромождаются вспомогательным кодом
- Гибкость — аспекты можно включать и выключать без изменения основной реализации
##### Недостатки АОП
- Сложность отладки — выполнение аспектов происходит «за кулисами», сложно отследить поток выполнения
- Оверхед — динамические прокси могут влиять на производительность
- Снижение читаемости при чрезмерном использовании аспектов — трудно понять, какие аспекты влияют на код
#### 14. Межсервисное взаимодействие. Микросервисная архитектура.

> **Def** Межсервисное взаимодействие — обмен данными и сообщениями между независимыми сервисами или приложениями, обеспечивающий их совместную работу и интеграцию.

> **Def** Асинхронный протокол — способ взаимодействия, при котором отправитель сообщения не ждёт немедленного ответа, а передаёт сообщение в систему обмена (например, в очередь). Обработка сообщения происходит независимо от отправителя.  
> Пример: AMQP (Advanced Message Queue Protocol).

> **Def** Синхронный протокол — способ взаимодействия, при котором клиент при отправке запроса ожидает ответ от сервиса, и задача завершается только после получения этого ответа.  
> Пример: HTTP.

> **Def** Система обмена сообщениями — инфраструктура и набор правил, позволяющих двум приложениям обмениваться сообщениями через определённый интерфейс, включающий протокол, формат и порядок сообщений.

Такая система отделяет отправителя от получателя, обеспечивая независимость реализации, а также позволяет работать с посредником (брокером сообщений), который управляет доставкой и маршрутизацией сообщений.

Рассмотрим пару разновидностей проблем, которые решает система обмена сообщениями, и введем некоторые основные термины.

> **Def** Point-to-Point — модель обмена сообщениями, при которой сообщение направляется в очередь и гарантированно доставляется ровно одному потребителю, независимо от его доступности в момент отправки.

- Сообщения в очереди обрабатываются по принципу FIFO (первый вошёл — первый вышел).
- Очереди могут быть «надежными» (durable), что гарантирует сохранение сообщений до доставки.
- Персистентность — запись сообщений в хранилище между отправкой и получением (отдельное свойство).
- Используется для задач, где важно однократное выполнение (например, оформление заказа).

> **Def** Publisher/Subscriber — модель обмена сообщениями, при которой сообщения публикуются в топик и распределяются всем подписчикам, при этом подписчики, не активные в момент публикации, пропускают сообщения.

- Топик работает как широковещательная конференция.
- Топики обычно ненадежны (nondurable) — сообщения не сохраняются для отсутствующих подписчиков
- Гарантируется доставка не более одного раза каждому подписчику.
- Используется для передачи информационных потоков, где потеря отдельных сообщений не критична (например, показания датчиков).

> **Def** Гибридная модель обмена сообщениями — сочетание моделей «точка-точка» и «публикация-подписка», позволяющее доставлять сообщения нескольким системам с гарантией надежности и персистентности, обеспечивая индивидуальное получение сообщений каждой заинтересованной стороной.

> **Def** Микросервисная архитектура — стиль построения приложений, в котором система состоит из набора независимых сервисов, каждый из которых реализует отдельную бизнес-функцию и взаимодействует с другими сервисами через сетевые протоколы.
##### Зачем нужна микросервисная архитектура?
Позволяет разрабатывать, масштабировать и развёртывать отдельные части системы независимо, повышает устойчивость к сбоям и позволяет использовать разные технологии под разные задачи.
##### История появления
Возникла как ответ на сложности масштабирования и поддержки больших монолитных приложений, где внутренние компоненты взаимодействовали внутрипроцессно.

##### Проблемы перехода
- Нет универсального решения для организации взаимодействия микросервисов.
- Возможна изоляция бизнес-значимых сервисов с асинхронным взаимодействием и агрегированием данных.
- Либо создание частично зависимых, но согласованных микросервисов с разделением данных и логики.

#### 15. Какие ключевые задачи решают брокеры сообщений? Перечислите известные вам модели обмена сообщениями и протоколы.
##### Какие ключевые задачи решают брокеры сообщений? Перечислите известные вам модели обмена сообщениями и протоколы.

> **Def:** **Брокер сообщений** — это посредник, обеспечивающий надёжную передачу сообщений между отправителями и получателями, реализующий различные модели обмена и гарантии доставки.
##### 1. Асинхронная коммуникация

> **Def:** Асинхронная коммуникация — обмен сообщениями без ожидания немедленного ответа.
- Отправитель публикует сообщение в брокер и продолжает работу.
- Получатель обрабатывает сообщение, когда готов, без прямой связи с отправителем.

##### 2. Буферизация и выравнивание нагрузки

> **Def:** Буферизация — накопление сообщений в очередях для последующей обработки.
- При пиковых нагрузках брокер сохраняет сообщения и распределяет их на потребителей по их скорости обработки.
##### 3. Гарантированная доставка

> **Def:** Гарантированная доставка — механизмы, предотвращающие потерю сообщений при сбоях
- **Acknowledgments:** брокер удаляет сообщение только после подтверждения (ack).
- **Персистентность:** запись сообщений на диск, чтобы они пережили перезапуск брокера.

##### 4. Маршрутизация сообщений

> **Def:** Маршрутизация — направлять сообщения разным получателям по заданным правилам.
- **RabbitMQ exchanges:** direct, topic, fanout.
- **Kafka topics:** разделение по именованным темам (orders, payments и т.д.).

##### 5. Масштабируемость

> **Def:** Масштабируемость — возможность обрабатывать всё большее число сообщений за счёт горизонтального расширения.
- Несколько потребителей одной очереди (конкурирующие потребители).
- Партиционирование (Kafka) для параллельной обработки

##### 6. Интеграция разнородных систем
> **Def:** Интеграция — объединение сервисов на разных языках и платформах через единый брокер.
- Поддержка стандартных протоколов (AMQP, MQTT, STOMP).


##### 7. Обеспечение отказоустойчивости

> **Def:** Отказоустойчивость — устойчивость системы к сбоям компонентов.
- **Повторная отправка** сообщений при ошибках.
- **Dead Letter Queue (DLQ):** хранение «проблемных» сообщений для последующей отладки.
##### Протоколы

- **JMS (Java Message Service)**  
    Стандарт API для обмена сообщениями в Java, не регламентирует сетевой протокол. Позволяет брокерам (ActiveMQ, OpenMQ) реализовать собственные протоколы (например, OpenWire).
- **AMQP (Advanced Message Queuing Protocol)**  
    Открытый двоичный протокол обмена сообщениями с поддержкой routing, транзакций и QoS (at-most-once, at-least-once, exactly-once).
- **MQTT (Message Queuing Telemetry Transport)**  
    Легковесный «публикация-подписка» протокол для IoT и M2M, оптимизирован для низкой пропускной способности и малых устройств.
- **STOMP (Simple/Streaming Text Oriented Messaging Protocol)**  
    Текстовый протокол, часто используется для интеграции с веб-клиентами (WebSocket).

##### Пример: ActiveMQ и JMS API

> **Def:** **JMS** — Java API для асинхронного обмена сообщениями, описывающий объекты ConnectionFactory, Connection, Session, MessageProducer, MessageConsumer и Message.
###### Основные компоненты JMS:
- **ConnectionFactory** — фабрика для создания соединений с брокером (например, `ActiveMQConnectionFactory`).
- **Connection** — долгоживущий потокобезопасный объект, представляющий соединение с брокером.
- **Session** — транзакционный дескриптор; не потокобезопасен; создаёт `MessageProducer`, `MessageConsumer`, `Message`.
- **MessageProducer** / **MessageConsumer** — отправка и получение сообщений. Потребитель может использовать `MessageListener` (асинхронно) или `receive()` (синхронно).
- **Message** — несёт метаданные (заголовки и свойства) и тело (payload).

###### Жизненный цикл отправки сообщения:

1. Клиент маршализует объект в `Message` и вызывает `send()`.
2. Брокер записывает сообщение в хранилище (persistence adapter).
3. После сохранения брокер посылает подтверждение (ack) клиенту.
4. Клиент продолжает работу.

###### Жизненный цикл получения сообщения:
1. Брокер загружает сообщения из хранилища в память (prefetch buffer).
2. Брокер отправляет сообщения потребителю, отслеживая, кому уже отправлено.
3. Потребитель обрабатывает сообщение и отправляет брокеру ack.
4. После получения ack брокер удаляет сообщение из памяти и хранилища.

Таким образом, брокеры сообщений обеспечивают надёжное, масштабируемое и разгруженное взаимодействие между сервисами, используя различные модели обмена и протоколы.
#### 16. Ключевые отличия Apache Kafka от RabbitMQ. Паттерн Outbox.

**Архитектура**

- **RabbitMQ** — классический брокер сообщений с архитектурой, основанной на _exchanges_, _queues_ и _bindings_, реализующий модели «публикация-подписка» и очереди задач.
- **Kafka** — распределённая потоковая платформа, использующая партиционированные топики и неизменяемые логи, где сообщения хранятся на диске с возможностью повторного чтения.

**Модель доставки**
- **RabbitMQ**:
    - Работает по _push-модели_: брокер сам доставляет сообщения потребителям.
    - Использует подтверждения _ACK/NACK_ для гарантии обработки.
    - Сообщения удаляются после обработки (если не включена персистентность).

- **Kafka**    
    - Реализует _pull-модель_: потребители сами запрашивают сообщения.
    - Сообщения хранятся в течение настраиваемого времени (retention period).
    - Потребители самостоятельно управляют смещением (_offset_), определяя, какие сообщения уже обработаны.

**Производительность**

- **RabbitMQ** оптимизирован для низкой задержки (миллисекунды), пропускная способность — тысячи сообщений в секунду.
- **Kafka** способна обрабатывать миллионы сообщений в секунду благодаря партиционированию и последовательной записи на диск.

**Использование**
- **RabbitMQ** подходит для:
    - Асинхронной коммуникации в микросервисах.
    - Сложной маршрутизации сообщений (topic-based routing).
    - Гарантированной доставки и транзакционных задач.
- **Kafka** лучше использовать для:
    - Потоковой обработки данных в реальном времени (real-time analytics, IoT).
    - Хранения больших объёмов данных и возможности повторной обработки (event sourcing).
    - Высоконагруженных систем (например, логирование).

##### Паттерн Outbox

**Проблема**  
В распределённых системах невозможно обеспечить атомарность одновременно записи в базу данных и отправки сообщения брокеру — возникает проблема _dual-write_, когда одна операция может выполниться, а другая — нет.

**Как работает Outbox?**

1. В рамках одной транзакции приложения происходит:
    - Запись данных в основную таблицу (например, `orders`).
    - Добавление события в специальную таблицу `outbox` в той же транзакции.
2. Отдельный фоновый процесс (Debezium, кастомный ретранслятор) читает записи из таблицы `outbox` и публикует их в Kafka или RabbitMQ.
3. Потребители сообщений должны быть идемпотентными — обрабатывать возможные дубликаты, например, по уникальному `event_id`.

**Преимущества Outbox*
- Гарантирует атомарность записи данных и событий, исключая рассинхронизацию.
- Повышает надёжность: события не теряются, даже если брокер временно недоступен.
- Масштабируемость: отправка сообщений осуществляется асинхронно, не блокируя основное приложение.

**Недостатки**

- Возникает задержка между изменением данных и публикацией события (не подходит для strict real-time).
- Усложняет архитектуру, требует дополнительных компонентов для чтения и публикации из таблицы `outbox`.
