# *Лабораторная работа №4*

> `Subqueries`

При написании запросов может возникнуть необходимость в данных,
полученных на предыдущем этапе. Возникает вопрос об актуальности данных.

Рассмотрим следующий пример:

Необходимо найти название самого дорогого товара с цветом Red.

Пользователь, не знакомый с механизмом использования подзапросов, может
написать следующий набор запросов:

```SQL
SELECT MAX(list_price) FROM production.product
WHERE color = 'Red'
```

Данный запрос вернет таблицу, одна строка и один столбец без имени, со
значением 3578,27. Подставив полученный результат в следующий запрос,
пользователь получит искомые данные:

```SQL
SELECT name FROM production.product
WHERE color = 'Red' AND list_price = 3578.27
```

При выполнении данных операций пользователь, во-первых, вынужден
выполнять промежуточные действия вручную, во-вторых, актуальность
полученных данных может быть поставлена под сомнение. Использование
подзапросов решит обе эти проблемы:

```SQL
SELECT name FROM production.product
WHERE color = 'Red' AND list_price =(
  SELECT MAX(list_price) FROM production.product
  WHERE color = 'Red'
)
```

> В данном случае показан простейший вариант использования подзапроса.
> Стоит отметить, что использован оператор сравнения на равенство, так
> как функция "MAX" гарантированно возвращает одно значение.

Допускается использование логических операторов для сравнения скалярного
значения с результатом выполнения подзапроса. Рассмотрим несколько
примеров:

Необходимо получить список товаров, цвет которых может быть любой, кроме
Red, а цена равна цене любого товара с цветом Red. Для этого можно
использовать следующий запрос:

```SQL
SELECT name FROM production.product
WHERE color != 'Red' AND list_price = ANY(
  SELECT list_price FROM production.product
  WHERE color = 'Red'
)
```

> Оператор сравнения использован вместе с логическим оператором \`ANY\`,
> так как подзапрос возвращает потенциально более одного значения.
> Логический оператор \`ANY\` сравнивает скалярное значение с набором
> значений, состоящим из одного столбца, и условие сравнения должно быть
> выполнено хотя бы для одного значения из набора.

Необходимо получить список товаров, цена которых больше цены любого из
товаров с цветом Red. Используем следующий запрос:


```SQL
SELECT name FROM production.product
WHERE list_price > ALL(
  SELECT list_price FROM production.product
  WHERE color = 'Red'
)
```

> Логический оператор \`ALL\` сравнивает скалярное значение с набором
> значений,
>
> состоящим из одного столбца, и условие сравнения должно быть выполнено
> для каждого значения из набора.

Необходимо получить название товаров, чей цвет совпадает с цветом одного
из товаров, чья цена больше 3000. Это можно сделать следующим
подзапросом:

```SQL
SELECT name FROM production.product
WHERE color IN(
  SELECT color FROM production.product
  WHERE list_price > 3000
)
```

> Логический оператор \`IN\` определяет, совпадает ли указанное значение
> с одним из значений, содержащихся во вложенном запросе или списке.

Подзапросы могут сами содержать подзапросы!

Следующий пример находит название категории, где содержится самый
дорогой товар:

```SQL
SELECT name FROM production.product_category
WHERE product_category_id IN(
  SELECT product_category_id FROM production.product_subcategory
  WHERE product_category_id IN(
    SELECT product_subcategory_id FROM production.product
    WHERE list_price = (
      SELECT MAX(list_price) FROM production.product
    )
  )
)
```

> Данную задачу можно было бы решить с помощью соединения таблиц,
> упорядочивания и выражения \`LIMIT\`, но использование подзапросов в
> данном случае предпочтительней, так как это позволяет избежать
> ресурсоемкой операции соединения. Это утверждение справедливо только
> для ситуаций, когда подзапрос простой.

Запрос может использовать более одного подзапроса на одном уровне
вложенности. Например, необходимо получить с помощью одного запроса
список товаров, у которых цвет совпадает с цветом самого дорогого
товара, и стиль совпадает со стилем самого дорого товара. Напишем
следующий запрос:

```SQL
SELECT name FROM production.product
WHERE color IN(
  SELECT color FROM production.product
  WHERE list_price = (
    SELECT MAX(list_price) FROM production.product
  ))
  AND style IN(
    SELECT style FROM production.product
  WHERE list_price =(
    SELECT MAX(list_price) FROM production.product
  )
)
```

> Все рассмотренные ранее подзапросы являлись ***простыми (не
> коррелирующие запросы)***, они возвращали фиксированный, неизменный
> набор данных, вне зависимости от того, с какой из строк запроса
> верхнего уровня в данный момент работает СУБД.

Подзапросы также используются для формирования выборки с использованием
конструкции `GROUP BY HAVING`.

Допустим, необходимо найти номер подкатегории товаров с наибольшим
количеством товаров. Данный запрос можно реализовать несколькими
способами, в том числе с использованием подзапроса:

```SQL
SELECT product_subcategory_id FROM production.product
GROUP BY product_subcategory_id
HAVING COUNT(*) = (
  SELECT COUNT(*) FROM production.product
  GROUP BY product_subcategory_id
  ORDER BY COUNT(*) DESC
  LIMIT 1
)
```

Рассмотрим следующую задачу:

Необходимо получить список самых дорогих товаров в каждой из
подкатегорий.

Подобную задачу можно решить с использованием ***сложного***
(коррелирующего) подзапроса.

Коррелирующим подзапросом называют такой подзапрос, который формирует
связанную выборку, зависимую от данных внешнего запроса. Фактически
коррелирующий подзапрос выполняется для каждой строки запроса верхнего
уровня.

```SQL
SELECT name FROM production.product AS P1
WHERE list_price =(
  SELECT MAX(list_price) FROM production.product AS P2
  WHERE P1.product_subcategory_id = P2.product_subcategory_id
)
```

Связанные подзапросы могут использоваться для формирования выводимого
столбца. Например, следующий запрос возвращает название продукта и
название подкатегории, к которой он относится:

```SQL
SELECT name, (
  SELECT name FROM production.product_subcategory AS PS
  WHERE P1.product_subcategory_id = PS.product_subcategory_id
)
FROM production.product AS P1
```

Выражения подзапросов:
- EXISTS
- IN
- NOT IN
- ANY / SOME
- ALL

**EXISTS** (подзапрос)

Аргументом `EXISTS` является обычный оператор `SELECT`, т. е.
подзапрос. Выполнив запрос, система проверяет, возвращает ли он строки в
результате. Если он возвращает минимум одну строку, результатом
`EXISTS` будет «true», а если не возвращает ни одной — «false».

Так как результат этого выражения зависит только от того, возвращаются
строки или нет, но не от их содержимого, список выходных значений
подзапроса обычно не имеет значения. Как следствие, широко
распространена практика, когда проверки `EXISTS` записываются в форме
`EXISTS(SELECT 1 WHERE ...)`. Однако из этого правила есть и
исключения, например с подзапросами с предложением `INTERSECT`.

Этот простой пример похож на внутреннее соединение по столбцу `col2`,
но он выдаёт максимум одну строку для каждой строки в `tab1`, даже
если в `tab2` ей соответствуют несколько строк:

```SQL
SELECT column FROM my_table
WHERE EXISTS (
  SELECT 1 FROM my_table_2
  WHERE color_2 = my_table.column_2
)
```

**IN** (подзапрос)

В правой стороне этого выражения в скобках задаётся подзапрос, который
должен возвращать ровно один столбец. Вычисленное значение левого
выражения сравнивается со значениями во всех строках, возвращённых
подзапросом. Результатом всего выражения `IN` будет «true», если
строка с таким значением находится, и «false» в противном случае (в том
числе, когда подзапрос вообще не возвращает строк).

Заметьте, что если результатом выражения слева оказывается NULL или
равных значений справа не находится, а хотя бы одно из значений справа
равно NULL, конструкция `IN` возвращает NULL, а не false. Это
соответствует принятым в SQL правилам сравнения переменных со значениями
NULL.

**NOT IN** (подзапрос)

Справа в скобках записывается подзапрос, который должен возвращать ровно
один столбец. Вычисленное значение левого выражения сравнивается со
значением во всех строках, возвращённых подзапросом. Результатом всего
выражения `NOT IN` будет «true», если находятся только несовпадающие
строки (в том числе, когда подзапрос вообще не возвращает строк). Если
найдется хотя бы одна подходящая строка, результатом будет «false».

Заметьте, что если результатом выражения слева оказывается `NULL` или
равных значений справа не находится, а хотя бы одно из значений справа
равно `NULL`, конструкция `NOT IN` возвращает `NULL`, а не true.
Это соответствует принятым в \`SQL\` правилам сравнения переменных со
значениями `NULL`.

**ANY** (подзапрос)

В правой части конструкции в скобках записывается подзапрос, который
должен возвращать ровно один столбец. Вычисленное значение левого
выражения сравнивается со значением в каждой строке результата
подзапроса с помощью заданного *\_\`оператора\`\_* условия, который
должен выдавать логическое значение. Результатом `ANY` будет «true»,
если хотя бы для одной строки условие истинно, и «false» в противном
случае (в том числе, и когда подзапрос не возвращает строк).

Ключевое слово `SOME` является синонимом \`ANY\`. Конструкцию \`IN\`
можно также записать как `= ANY`.

Заметьте, что если условие не выполняется ни для одной из строк, а хотя
бы для одной строки условный оператор выдаёт NULL, конструкция `ANY`
возвращает NULL, а не false. Это соответствует принятым в SQL правилам
сравнения переменных со значениями NULL.

**ALL** (подзапрос)

В правой части конструкции в скобках записывается подзапрос, который
должен возвращать ровно один столбец. Вычисленное значение левого
выражения сравнивается со значением в каждой строке результата
подзапроса с помощью заданного *\_\`оператора\`\_* условия, который
должен выдавать логическое значение. Результатом `ALL` будет «true»,
если условие истинно для всех строк (и когда подзапрос не возвращает
строк), или «false», если находятся строки, для которых оно ложно.
Результатом выражения будет `NULL`, если ни для одной из строк
подзапроса результат сравнения не равен true, а минимум для одной равен
`NULL`.

Конструкция `NOT IN` равнозначна `<> ALL`.
